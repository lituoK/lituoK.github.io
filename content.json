{"meta":{"title":"醒来","subtitle":"","description":"","author":"LiTuo","url":"http://example.com","root":"/"},"pages":[],"posts":[{"title":"Leetcode327. 区间和的个数","slug":"lc-327","date":"2020-11-07T16:00:00.000Z","updated":"2020-11-08T08:18:54.448Z","comments":true,"path":"2020-11-08/lc-327/","link":"","permalink":"http://example.com/2020-11-08/lc-327/","excerpt":"","text":"题目327. 区间和的个数思路 &amp; 代码要求一个数组的某一区间和，我们可以利用前缀和算法。 设：数组nums是下标从1~n的数组，那么他的前缀和就是sum[i] = nums[1] + nums[2] + nums[3] + ... + nums[i]，我们可以用下面的代码实现： 1for(int i = 1; i &lt;= n; i ++ ) sum[i] = sum[i - 1] + nums[i]; 因为本题的nums数组是从0开始的，所以我们可以稍微修改一下（sum数组仍然从1开始）： 1for(int i = 1; i &lt;= n; i ++ ) sum[i] = sum[i - 1] + nums[i - 1]; 那么有了sum数组，我们就可以在O(1)的时间复杂度查询到任意区间内的区间和： 1sum[j : i] = sum[i] - sum[j - 1] = nums[j] + nums[j + 1] + ... + nums[i - 1] + nums[i] 本体的题意是找到区间[i, j]的区间和sum[j : i]和在给定范围的区间个数，也就是说，找到所有满足下列公式的区间： 123lower &lt;= sum[i] - sum[j] &lt;= upper; 1 &lt;= i &lt;= n, 0 &lt;= j &lt;= i - 1;等价变换：sum[i] - upper &lt;= sum[j] &lt;= sum[i] - lower; ---- 公式1 所以，我们的任务就是对于每一个sum[i], 找到满足公式1的sum[j]的个数; 我们可以通过这个思路写出一个时间复杂度为O(n^2)的算法,代码如下： 朴素版 O(n^2)12345678910111213141516171819class Solution &#123;public: typedef long long LL; int countRangeSum(vector&lt;int&gt;&amp; nums, int lower, int upper) &#123; int n = nums.size(); vector&lt;LL&gt; sum(n + 1); // 求区间和 for(int i = 1; i &lt;= n; i ++) sum[i] = sum[i - 1] + nums[i - 1]; int res = 0; // 对于每一个sum[i], 找到满足`公式1`的sum[j]的个数 for(int i = 1; i &lt;= n; i ++)&#123; LL a = sum[i] - upper, b = sum[i] - lower; for(int j = 0; j &lt; i; j ++ ) if(a &lt;= sum[j] &amp;&amp; sum[j] &lt;= b) res ++ ; &#125; return res; &#125;&#125;; 但是这样做会TLE，所以我们就要通过一些方法优化一下时间复杂度。我们可以想象一个容器，我们可以把数插入进去，然后在很短的时间内，查询到这个容器中有多少个数是在给定范围的。如果存在这样一个数据结构，我们就可以很方便的遍历前缀和数组sum,然后查询容器中有多少数是在范围[sum[i] - upper, sum[i] - lower]中的，然后我们再将sum[i]插入到容器中去。 要实现这样的数据结构，我们需要学习离散化和树状数组或线段树算法。 树状数组 O(nlogn)以下内容涉及离散化和树状数组的相关知识 将’sum[i], sum[i] - upper - 1, sum[i] - lower’离散化； 使用一个抽象的数组a，维护数组sum中的元素出现的次数。 使用树状数组，维护数组a，使得我们可以在O(logn)的时间复杂度内，将sum[i]出现的次数+1， 查询有多少sum[j]是在范围[sum[i] - upper, sum[i] - lower]内的。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152class Solution &#123;public: typedef long long LL; vector&lt;LL&gt; sum, vals, tr; int n; // 离散化 int get(LL x)&#123; int l = 0, r = vals.size() - 1; while(l &lt; r)&#123; int mid = (l + r) / 2; if(vals[mid] &gt;= x) r = mid; else l = mid + 1; &#125; return l + 1; &#125; // 树状数组的基本操作 int lowerbit(int x)&#123; return x &amp; -x; &#125; // 单点修改 void add(int x, int v)&#123; for(int i = x; i &lt; tr.size(); i += lowerbit(i)) tr[i] += v; &#125; // 区间查询 int query(int x)&#123; int res = 0; for(int i = x; i; i -= lowerbit(i)) res += tr[i]; return res; &#125; int countRangeSum(vector&lt;int&gt;&amp; nums, int lower, int upper) &#123; n = nums.size(); sum = vector&lt;LL&gt;(n + 1); // 将&#x27;sum[i], sum[i] - upper - 1, sum[i] - lower&#x27;离散化； for(int i = 0; i &lt;= n; i ++)&#123; if(i) sum[i] = sum[i - 1] + nums[i - 1]; vals.push_back(sum[i]); vals.push_back(sum[i] - upper - 1); vals.push_back(sum[i] - lower); &#125; sort(vals.begin(), vals.end()); vals.erase(unique(vals.begin(), vals.end()), vals.end()); // 树状数组 tr.resize(vals.size() + 1); int res = 0; for(int i = 0; i &lt;= n; i ++ )&#123; res += query(get(sum[i] - lower)) - query(get(sum[i] - upper - 1)); add(get(sum[i]), 1); &#125; return res; &#125;&#125;; 线段树 O(nlogn)我们使用的是不带懒标记的线段树，实现的功能也是单点修改，区间查询。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081class Solution &#123;public: typedef long long LL; typedef struct&#123; int l, r, sum; &#125;Node; vector&lt;Node&gt; tr; vector&lt;LL&gt; sum, vals; int n; // 离散化 int get(LL x)&#123; int l = 0, r = vals.size() - 1; while(l &lt; r)&#123; int mid = l + r &gt;&gt; 1; if(vals[mid] &gt;= x) r = mid; else l = mid + 1; &#125; return l + 1; &#125; // 线段树基本操作 void pushup(int u)&#123; tr[u].l = tr[u &lt;&lt; 1].l, tr[u].r = tr[u &lt;&lt; 1 | 1].r; tr[u].sum = tr[u &lt;&lt; 1].sum + tr[u &lt;&lt; 1 | 1].sum; &#125; // 建树 void build(int u, int l, int r)&#123; if(l == r)&#123; tr[u].l = tr[u].r = l; return; &#125; int mid = (l + r) &gt;&gt; 1; build(u &lt;&lt; 1, l, mid); build(u &lt;&lt; 1 | 1, mid + 1, r); pushup(u); &#125; // 区间查询 int query(int u, int l, int r)&#123; if(l &lt;= tr[u].l &amp;&amp; tr[u].r &lt;= r) return tr[u].sum; int mid = tr[u].l + tr[u].r &gt;&gt; 1; int res = 0; if(mid &gt;= l) res += query(u &lt;&lt; 1, l, r); if(mid &lt; r) res += query(u &lt;&lt; 1 | 1, l, r); return res; &#125; // 单点修改 void modify(int u, int x, int v)&#123; if(tr[u].l == x &amp;&amp; tr[u].r == x)&#123; tr[u] = &#123;x, x, tr[u].sum + v&#125;; return; &#125; int mid = tr[u].l + tr[u].r &gt;&gt; 1; if(x &lt;= mid) modify(u &lt;&lt; 1, x, v); else modify(u &lt;&lt; 1 | 1, x, v); pushup(u); &#125; int countRangeSum(vector&lt;int&gt;&amp; nums, int lower, int upper) &#123; n = nums.size(); sum.resize(n + 1); // 求前缀和，并且离散化 for(int i = 0; i &lt;= n; i ++ )&#123; if(i) sum[i] = sum[i - 1] + nums[i - 1]; vals.push_back(sum[i]); vals.push_back(sum[i] - upper); vals.push_back(sum[i] - lower); &#125; sort(vals.begin(), vals.end()); vals.erase(unique(vals.begin(), vals.end()), vals.end()); tr.resize(vals.size() * 4 + 10); // 建树 build(1, 1, vals.size()); int res = 0; // 遍历，求结果并插入到线段树中。 for(int i = 0; i &lt;= n; i ++ )&#123; res += query(1, get(sum[i] - upper), get(sum[i] - lower)); modify(1, get(sum[i]), 1); &#125; return res; &#125;&#125;;","categories":[],"tags":[]},{"title":"1356. 根据数字二进制下 1 的数目排序","slug":"lc-1356","date":"2020-11-05T16:00:00.000Z","updated":"2020-11-06T07:00:16.143Z","comments":true,"path":"2020-11-06/lc-1356/","link":"","permalink":"http://example.com/2020-11-06/lc-1356/","excerpt":"","text":"题目1356. 根据数字二进制下 1 的数目排序思路统计每个数对应的二进制数的1的个数，然后根据1的个数排序即可。 怎么统计二进制数中1的个数呢？我们可以遍历这个数的每一位，如果这位是1，就计数。这样就可以得到结果了。 代码12345int f(int x)&#123; int cnt = 0; for(int i = 0; i &lt; 32; i ++ ) cnt += (x &gt;&gt; i) &amp; 1; return cnt;&#125; 这样每个数都要遍历32位，在python中一个数可能也不止32位，我们如何得到这个数的1的个数呢？ 可以使用lowerbit算法，lowerbit是一个常用的算法，可以用来得到一个数的最低一位1所在的位置，比如说 $ 6d = 110b $ ，6的最低一位1出现在第二位，lowerbit算法就会返回 $ 10b = 2d $ (b和d分别表示二进制和十进制)。同理 $ lowerbit(8) = 8, lowerbit(12) = 4, …. $ lowerbit算法的代码很简单，只有一行具体的证明请同学们自己思考或者搜索。 代码123int lowerbit(int x)&#123; return x &amp; -x;&#125; 通过lowerbit算法我们如何得到一个数的二进制数中1的个数呢？其实很简单，只要每次找到最低一位1，然后计数，将这个最低一位1从数中减去，直到数为0即可. 代码12345int f(int x)&#123; int cnt = 0; while(x) x -= lowerbit(x), cnt ++ ; return cnt;&#125; 现在我们得到了求一个数的二进制数中1的个数的算法，我们要求数组arr中的所有数的二进制数1的个数，只需要遍历即可。 那么我们可不可以继续优化这个算法的时间复杂度呢？我们可以通过动态规划来进行优化, 给定一个数x，如果我们已知 $ x - lowerbit(x) $ 中有多少个1，那么x就比 $ x - lowerbit(x) $ 多一个1.状态转移方程： f(x) = f(x - lowerbit(x)) + 1 代码12345vector&lt;int&gt; cnt; // cnt[i]记录数字i对应二进制数中1的个数int f(int x)&#123; if(x == 0 || cnt[x] != 0) return cnt[x]; //这个数之前计算过 return cnt[x] = f(x - lowerbit(x)) + 1; // 状态转移方程&#125; 好的，以上就是对于计算一个二进制数中1的个数的算法的优化过程。算法还是挺有趣的，大家加油哦~ 代码123456789101112131415161718192021class Solution &#123;public: vector&lt;int&gt; cnt; // cnt[i]记录数字i对应二进制数中1的个数 // 计算数x对应的二进制数中1的个数 int f(int x)&#123; if(!x || cnt[x] != 0) return cnt[x]; return cnt[x] = f(x - (x &amp; -x)) + 1; &#125; vector&lt;int&gt; sortByBits(vector&lt;int&gt;&amp; arr) &#123; cnt = vector&lt;int&gt;(10010); for(auto t : arr) f(t); sort(arr.begin(), arr.end(), [](int a, int b)-&gt;bool&#123; // 如果两个数a和b对应的二进制数中1的个数不同,1的个数少的在前面 if(cnt[a] != cnt[b]) return cnt[a] &lt; cnt[b]; // 如果相同，小的在前面 return a &lt; b; &#125;); return arr; &#125;&#125;; 附 lambda表达式lambda表达式：很多语言都有的语法糖，可以用来创建匿名函数，简化函数的书写。在sort函数中经常使用，因为我对C++的了解也仅限于做题。所以大家自行搜索吧，hhhh。附上一篇我觉得还可以的博客。 lambda表达式","categories":[],"tags":[]},{"title":"LeetCode127.单词接龙","slug":"lc-127","date":"2020-11-04T16:00:00.000Z","updated":"2020-11-05T09:43:20.966Z","comments":true,"path":"2020-11-05/lc-127/","link":"","permalink":"http://example.com/2020-11-05/lc-127/","excerpt":"","text":"题目127. 单词接龙思路使用广度优先搜索，给定一个单词，搜索其所有可能得到的单词，如果变化后单词在给定的单词集合中，就将其加入到队列中，直到找到最终的单词或者队列为空。 代码1234567891011121314151617181920212223242526272829303132333435class Solution &#123;public: int ladderLength(string beginWord, string endWord, vector&lt;string&gt;&amp; wordList) &#123; // 记录给定的单词集合 unordered_set&lt;string&gt; st; for(auto s : wordList) st.insert(s); // 记录每个单词距离beginword的距离 // 就是beginword改变多少单词可以得到这个单词 unordered_map&lt;string, int&gt; dict; // 起始距离设为1 dict.insert(&#123;beginWord, 1&#125;); // bfs队列 queue&lt;string&gt; q; q.push(beginWord); while(q.size())&#123; auto t = q.front(); q.pop(); // 如果找到答案了，返回结果 if(t == endWord) return dict[t]; // 所有改变一次能得到的单词 for(int i = 0; i &lt; t.size(); i ++ )&#123; auto r = t; for(char c = &#x27;a&#x27;; c &lt;= &#x27;z&#x27;; c ++ )&#123; r[i] = c; // 如果这个单词在集合中，且之前没有被访问过 if(st.count(r) &amp;&amp; !dict.count(r))&#123; q.push(r); dict[r] = dict[t] + 1; &#125; &#125; &#125; &#125; // 没有答案 return 0; &#125;&#125;;","categories":[],"tags":[]},{"title":"57. 插入区间","slug":"lc-57","date":"2020-11-03T16:00:00.000Z","updated":"2020-11-04T04:58:19.907Z","comments":true,"path":"2020-11-04/lc-57/","link":"","permalink":"http://example.com/2020-11-04/lc-57/","excerpt":"","text":"题目57. 插入区间思路这道题就是一个区间合并的题，首先给定一组有序的区间，和一个要插入的区间，我们可以把这组区间分成三类 在要插入的区间左边，没有交集的区间 和给定区间可以合并成一个区间的区间 最后是剩下的和合并后的区间没有交集的区间。 设：给定区间的左右断点分别为l和r。 对于三类区间： 首先，因为给定的区间都是有序的，所以我们可以先把这些数组加入到答案中，这些数组的都在给定区间的左边，所以他们的右端点是一定在给定区间的左端点的左边的，也就是$intervals[i][1] &lt; l$。 对于第二类区间，是我们要处理的区间，因为我们要将他们进行合并，先想一想他们具有什么样的特征，因为我们目前已经把$intervals[i][1] &lt; l$的区间都排除掉了，所以剩下的区间一定满足$intervals[i][1] &gt;= l$；然后在这些区间里面，什么样的区间是可以和我们给定的区间进行合并的呢？我们先将区间[l, r]初始化为给定的区间，然后我们将所有可以合并的区间合并进去。如果$intervals[i][0] &lt;= r$那么就表示，这个区间的左端点是在我们给定的区间内的，我们就更新区间[l, r] 对于第三类区间，和第一类相同，直接加入到答案里面。 代码1234567891011121314151617181920class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; insert(vector&lt;vector&lt;int&gt;&gt;&amp; intervals, vector&lt;int&gt;&amp; newInterval) &#123; vector&lt;vector&lt;int&gt;&gt; res; // 初始化要合并的区间 int l = newInterval[0], r = newInterval[1]; int i = 0; // 下面将区间分成三类，挨个遍历 // 没有交集的区间 while(i &lt; intervals.size() &amp;&amp; intervals[i][1] &lt; l) res.push_back(intervals[i ++ ]); // 可以合并的区间 while(i &lt; intervals.size() &amp;&amp; intervals[i][0] &lt;= r) l = min(l, intervals[i][0]), r = max(r, intervals[i][1]), i ++ ; res.push_back(&#123;l, r&#125;); // 没有交集的区间 while(i &lt; intervals.size()) res.push_back(intervals[i ++ ]); return res; &#125;&#125;;","categories":[],"tags":[],"author":"Lituo"},{"title":"941. 有效的山脉数组","slug":"lc-941","date":"2020-11-02T16:00:00.000Z","updated":"2020-11-02T23:51:05.676Z","comments":true,"path":"2020-11-03/lc-941/","link":"","permalink":"http://example.com/2020-11-03/lc-941/","excerpt":"","text":"题目941. 有效的山脉数组思路模拟题，扫描一遍数组，如果是单调升+单调降的话，就返回true，否则返回false 代码12345678910class Solution &#123;public: bool validMountainArray(vector&lt;int&gt;&amp; A) &#123; int i = 0; while(i + 1 &lt; A.size() &amp;&amp; A[i] &lt; A[i + 1]) i ++ ; if(i == 0 || i == A.size() - 1) return false; while(i + 1 &lt; A.size() &amp;&amp; A[i] &gt; A[i + 1]) i ++ ; return i == A.size() - 1; &#125;&#125;;","categories":[],"tags":[],"author":"Lituo"},{"title":"349. 两个数组的交集","slug":"lc-349","date":"2020-11-02T00:32:11.000Z","updated":"2020-11-02T00:33:28.785Z","comments":true,"path":"2020-11-02/lc-349/","link":"","permalink":"http://example.com/2020-11-02/lc-349/","excerpt":"","text":"题目349. 两个数组的交集思路使用一个hash表，存储一个数组的所有元素，然后再遍历另一个数组，如果hash表中存在这个元素，就把它加入到答案中。 因为答案是没有重复的，所以在遍历另一个数组的时候，在向答案数组中添加元素的时候，我们就把这个元素从hash表中删除，这样就不会有重复的元素了。 代码123456789101112131415161718192021class Solution &#123;public: vector&lt;int&gt; intersection(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) &#123;​ vector&lt;int&gt; res;​ unordered_set&lt;int&gt; st;​ for(auto t : nums1) st.insert(t);​ for(auto t : nums2)​ if(st.count(t)) st.erase(t), res.push_back(t);​ return res; &#125;&#125;;","categories":[],"tags":[]}],"categories":[],"tags":[]}