{"meta":{"title":"醒来","subtitle":"","description":"","author":"LiTuo","url":"http://example.com","root":"/"},"pages":[],"posts":[{"title":"1356. 根据数字二进制下 1 的数目排序","slug":"lc-1356","date":"2020-11-05T16:00:00.000Z","updated":"2020-11-06T06:52:40.124Z","comments":true,"path":"2020-11-06/lc-1356/","link":"","permalink":"http://example.com/2020-11-06/lc-1356/","excerpt":"","text":"题目1356. 根据数字二进制下 1 的数目排序思路统计每个数对应的二进制数的1的个数，然后根据1的个数排序即可。 怎么统计二进制数中1的个数呢？我们可以遍历这个数的每一位，如果这位是1，就计数。这样就可以得到结果了。 代码12345int f(int x)&#123; int cnt = 0; for(int i = 0; i &lt; 32; i ++ ) cnt += (x &gt;&gt; i) &amp; 1; return cnt;&#125; 这样每个数都要遍历32位，在python中一个数可能也不止32位，我们如何得到这个数的1的个数呢？ 可以使用lowbit算法，lowbit是一个常用的算法，可以用来得到一个数的最低一位1所在的位置，比如说$6d = 110b$ ，6的最低一位1出现在第二位，lowbit算法就会返回$10b = 2d$ (b和d分别表示二进制和十进制)。同理$lowbit(8) = 8, lowbit(12) = 4, ….$lowbit的代码很简单，只有一行具体的证明请同学们自己思考或者搜索。 代码123int lowbit(int x)&#123; return x &amp; -x;&#125; 通过lowbit算法我们如何得到一个数的二进制数中1的个数呢？其实很简单，只要每次找到最低一位1，然后计数，将这个最低一位1从数中减去，直到数为0即可. 代码12345int f(int x)&#123; int cnt = 0; while(x) x -= lowbit(x), cnt ++ ; return cnt;&#125; 现在我们得到了求一个数的二进制数中1的个数的算法，我们要求数组arr中的所有数的二进制数1的个数，只需要遍历即可。 那么我们可不可以继续优化这个算法的时间复杂度呢？我们可以通过动态规划来进行优化, 给定一个数x，如果我们已知$x - lowbit(x)$中有多少个1，那么x就比$x - lowbit(x)$多一个1.状态转移方程： f(x) = f(x - lowbit(x)) + 1 代码12345vector&lt;int&gt; cnt; // cnt[i]记录数字i对应二进制数中1的个数int f(int x)&#123; if(x == 0 || cnt[x] != 0) return cnt[x]; //这个数之前计算过 return cnt[x] = f(x - lowbit(x)) + 1; // 状态转移方程&#125; 好的，以上就是对于计算一个二进制数中1的个数的算法的优化过程。算法还是挺有趣的，大家加油哦~ 代码123456789101112131415161718192021class Solution &#123;public: vector&lt;int&gt; cnt; // cnt[i]记录数字i对应二进制数中1的个数 // 计算数x对应的二进制数中1的个数 int f(int x)&#123; if(!x || cnt[x] != 0) return cnt[x]; return cnt[x] = f(x - (x &amp; -x)) + 1; &#125; vector&lt;int&gt; sortByBits(vector&lt;int&gt;&amp; arr) &#123; cnt = vector&lt;int&gt;(10010); for(auto t : arr) f(t); sort(arr.begin(), arr.end(), [](int a, int b)-&gt;bool&#123; // 如果两个数a和b对应的二进制数中1的个数不同,1的个数少的在前面 if(cnt[a] != cnt[b]) return cnt[a] &lt; cnt[b]; // 如果相同，小的在前面 return a &lt; b; &#125;); return arr; &#125;&#125;; 附 lambda表达式lambda表达式：很多语言都有的语法糖，可以用来创建匿名函数，简化函数的书写。在sort函数中经常使用，因为我对C++的了解也仅限于做题。所以大家自行搜索吧，hhhh。附上一篇我觉得还可以的博客。 lambda表达式","categories":[],"tags":[]},{"title":"LeetCode127.单词接龙","slug":"lc-127","date":"2020-11-04T16:00:00.000Z","updated":"2020-11-05T09:43:20.966Z","comments":true,"path":"2020-11-05/lc-127/","link":"","permalink":"http://example.com/2020-11-05/lc-127/","excerpt":"","text":"题目127. 单词接龙思路使用广度优先搜索，给定一个单词，搜索其所有可能得到的单词，如果变化后单词在给定的单词集合中，就将其加入到队列中，直到找到最终的单词或者队列为空。 代码1234567891011121314151617181920212223242526272829303132333435class Solution &#123;public: int ladderLength(string beginWord, string endWord, vector&lt;string&gt;&amp; wordList) &#123; // 记录给定的单词集合 unordered_set&lt;string&gt; st; for(auto s : wordList) st.insert(s); // 记录每个单词距离beginword的距离 // 就是beginword改变多少单词可以得到这个单词 unordered_map&lt;string, int&gt; dict; // 起始距离设为1 dict.insert(&#123;beginWord, 1&#125;); // bfs队列 queue&lt;string&gt; q; q.push(beginWord); while(q.size())&#123; auto t = q.front(); q.pop(); // 如果找到答案了，返回结果 if(t == endWord) return dict[t]; // 所有改变一次能得到的单词 for(int i = 0; i &lt; t.size(); i ++ )&#123; auto r = t; for(char c = &#x27;a&#x27;; c &lt;= &#x27;z&#x27;; c ++ )&#123; r[i] = c; // 如果这个单词在集合中，且之前没有被访问过 if(st.count(r) &amp;&amp; !dict.count(r))&#123; q.push(r); dict[r] = dict[t] + 1; &#125; &#125; &#125; &#125; // 没有答案 return 0; &#125;&#125;;","categories":[],"tags":[]},{"title":"57. 插入区间","slug":"lc-57","date":"2020-11-03T16:00:00.000Z","updated":"2020-11-04T04:58:19.907Z","comments":true,"path":"2020-11-04/lc-57/","link":"","permalink":"http://example.com/2020-11-04/lc-57/","excerpt":"","text":"题目57. 插入区间思路这道题就是一个区间合并的题，首先给定一组有序的区间，和一个要插入的区间，我们可以把这组区间分成三类 在要插入的区间左边，没有交集的区间 和给定区间可以合并成一个区间的区间 最后是剩下的和合并后的区间没有交集的区间。 设：给定区间的左右断点分别为l和r。 对于三类区间： 首先，因为给定的区间都是有序的，所以我们可以先把这些数组加入到答案中，这些数组的都在给定区间的左边，所以他们的右端点是一定在给定区间的左端点的左边的，也就是$intervals[i][1] &lt; l$。 对于第二类区间，是我们要处理的区间，因为我们要将他们进行合并，先想一想他们具有什么样的特征，因为我们目前已经把$intervals[i][1] &lt; l$的区间都排除掉了，所以剩下的区间一定满足$intervals[i][1] &gt;= l$；然后在这些区间里面，什么样的区间是可以和我们给定的区间进行合并的呢？我们先将区间[l, r]初始化为给定的区间，然后我们将所有可以合并的区间合并进去。如果$intervals[i][0] &lt;= r$那么就表示，这个区间的左端点是在我们给定的区间内的，我们就更新区间[l, r] 对于第三类区间，和第一类相同，直接加入到答案里面。 代码1234567891011121314151617181920class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; insert(vector&lt;vector&lt;int&gt;&gt;&amp; intervals, vector&lt;int&gt;&amp; newInterval) &#123; vector&lt;vector&lt;int&gt;&gt; res; // 初始化要合并的区间 int l = newInterval[0], r = newInterval[1]; int i = 0; // 下面将区间分成三类，挨个遍历 // 没有交集的区间 while(i &lt; intervals.size() &amp;&amp; intervals[i][1] &lt; l) res.push_back(intervals[i ++ ]); // 可以合并的区间 while(i &lt; intervals.size() &amp;&amp; intervals[i][0] &lt;= r) l = min(l, intervals[i][0]), r = max(r, intervals[i][1]), i ++ ; res.push_back(&#123;l, r&#125;); // 没有交集的区间 while(i &lt; intervals.size()) res.push_back(intervals[i ++ ]); return res; &#125;&#125;;","categories":[],"tags":[],"author":"Lituo"},{"title":"941. 有效的山脉数组","slug":"lc-941","date":"2020-11-02T16:00:00.000Z","updated":"2020-11-02T23:51:05.676Z","comments":true,"path":"2020-11-03/lc-941/","link":"","permalink":"http://example.com/2020-11-03/lc-941/","excerpt":"","text":"题目941. 有效的山脉数组思路模拟题，扫描一遍数组，如果是单调升+单调降的话，就返回true，否则返回false 代码12345678910class Solution &#123;public: bool validMountainArray(vector&lt;int&gt;&amp; A) &#123; int i = 0; while(i + 1 &lt; A.size() &amp;&amp; A[i] &lt; A[i + 1]) i ++ ; if(i == 0 || i == A.size() - 1) return false; while(i + 1 &lt; A.size() &amp;&amp; A[i] &gt; A[i + 1]) i ++ ; return i == A.size() - 1; &#125;&#125;;","categories":[],"tags":[],"author":"Lituo"},{"title":"349. 两个数组的交集","slug":"lc-349","date":"2020-11-02T00:32:11.000Z","updated":"2020-11-02T00:33:28.785Z","comments":true,"path":"2020-11-02/lc-349/","link":"","permalink":"http://example.com/2020-11-02/lc-349/","excerpt":"","text":"题目349. 两个数组的交集思路使用一个hash表，存储一个数组的所有元素，然后再遍历另一个数组，如果hash表中存在这个元素，就把它加入到答案中。 因为答案是没有重复的，所以在遍历另一个数组的时候，在向答案数组中添加元素的时候，我们就把这个元素从hash表中删除，这样就不会有重复的元素了。 代码123456789101112131415161718192021class Solution &#123;public: vector&lt;int&gt; intersection(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) &#123;​ vector&lt;int&gt; res;​ unordered_set&lt;int&gt; st;​ for(auto t : nums1) st.insert(t);​ for(auto t : nums2)​ if(st.count(t)) st.erase(t), res.push_back(t);​ return res; &#125;&#125;;","categories":[],"tags":[]}],"categories":[],"tags":[]}