{"meta":{"title":"醒来","subtitle":"","description":"","author":"LiTuo","url":"http://example.com","root":"/"},"pages":[],"posts":[{"title":"Leetcode31. 下一个排列","slug":"lc-31","date":"2020-11-09T16:00:00.000Z","updated":"2020-11-10T06:35:28.373Z","comments":true,"path":"2020-11-10/lc-31/","link":"","permalink":"http://example.com/2020-11-10/lc-31/","excerpt":"","text":"题目31. 下一个排列 思路我们这道题是要找到一个给定的数的下一个排列，也就是找到同样由给定的数的各位数字排列而成的最小的大于给定的数的数。 先给出算法的步骤： 从后往前，扫描数组nums，找到最小的j使得nums[i: n]是降序（不升序）排列的。 如果i == 0,说明整个数组降序（不升序）排列，逆转整个数组之后输出。 在nums[i: n]中找到一个最小的大于nums[i - 1]的数，并将其与nums[i - 1]对换。 将nums[i: n]翻转。 然后举个例子，对于数字123我们可以很简单的找到比它大的数132, 312, ….;而它的下一个排列就是132。132就是由1， 2， 3三位数组成的最小的比123大的数字。 然后我们先想一下特殊情况，什么样的数字是没有比他大的下一个排列的呢？那就是一个从低位到高位升序或者不降序排列的数。比如说321,它就是由1， 2， 3三位数字组成的最大数了。遇到这种情况我们应该怎么办呢？我们要给出由这三位数给出的最小排列，也就是123，我们只需要一个排序就搞定了。 12vector&lt;int&gt; a = &#123;3, 2, 1&#125;;sort(a.begin(), a.end()); // &#123;1, 2, 3&#125; 那么对于更一般的情况，我们怎么找到其下一个排列呢？题目的要求是找到比当前数大的最小排列。要做到这一点，我们就要尽量的保持高位不变，然后让低位变动的幅度最小。 为了做到这一点，我们先从低位开始扫描，如果遇到第一个不符合升序或者不降序排列，我们就停下来。例如：1247664，我们从4开始扫描，7664从低到高都是不降序排列的。但是到47664中的4, 因为4&lt;7，所以到7，我们就停下来。 因为在上面我们说的，一个升序或者不降序排列的数，是没有比它大的下一个排列的，所以我们就把它的下一个数包括进来，在上例就是47664, 然后我们找比它大的下一个排列就可以了。 这个问题很简单，我们只要在7664里面找到一个比4大的最小的数,也就是6, 将两者交换，变为67644,因为任意6开头的数字, 都比47664要大，而我们想要的是最小的，因为这个数（7664）仍然是升序或者不降序排列的数，所以我们就把7644翻转,变为4467，然后就可以得到64467这个比47664大的最小排列了。 最后，高位不用动，就能得到我们想要的最小排列了。在本例中，也就是1264467。 代码C++12345678910111213141516171819class Solution &#123;public: void nextPermutation(vector&lt;int&gt;&amp; nums) &#123; int i = nums.size() - 1; // 从后往前扫描数组，找到最小的j使得nums[j: n]是降序（不升序）排列的。 while(i &amp;&amp; nums[i - 1] &gt;= nums[i]) i -- ; // 如果j == 0,说明整个数组降序（不升序）排列，逆转整个数组之后输出。 // 否则进行下列操作 if(i)&#123; // 在nums[j: n]中找到一个最小的大于nums[j - 1]的数，并将其与nums[j - 1]对换。 int k = nums.size() - 1; while(nums[k] &lt;= nums[i - 1]) k -- ; swap(nums[k], nums[i - 1]); &#125; // 进行响应的翻转 // 注意，此时i可以为0也可以不是0. reverse(nums.begin() + i, nums.end()); &#125;&#125;; Java123456789101112131415161718192021222324252627class Solution &#123; public void swap(int[] a, int i, int j)&#123; int t = a[i]; a[i] = a[j]; a[j] = t; &#125; public void reverse(int[] a, int start)&#123; for(int i = start, j = a.length - 1; i &lt; j; i ++, j -- ) swap(a, i, j); &#125; public void nextPermutation(int[] nums) &#123; int i = nums.length - 1; // 从后往前扫描数组，找到最小的j使得nums[j: n]是降序（不升序）排列的。 while(i &gt; 0 &amp;&amp; nums[i] &lt;= nums[i - 1]) i -- ; // 如果j == 0,说明整个数组降序（不升序）排列，逆转整个数组之后输出。 // 否则进行下列操作 if(i &gt; 0)&#123; // 在nums[j: n]中找到一个最小的大于nums[j - 1]的数，并将其与nums[j - 1]对换。 int k = nums.length - 1; while(nums[k] &lt;= nums[i - 1]) k -- ; swap(nums, i - 1, k); &#125; // 进行响应的翻转 // 注意，此时i可以为0也可以不是0. reverse(nums, i); &#125;&#125;","categories":[],"tags":[],"author":"李拓"},{"title":"Leetcode973. 最接近原点的 K 个点","slug":"lc-973","date":"2020-11-08T16:00:00.000Z","updated":"2020-11-09T00:02:44.067Z","comments":true,"path":"2020-11-09/lc-973/","link":"","permalink":"http://example.com/2020-11-09/lc-973/","excerpt":"","text":"题目973. 最接近原点的 K 个点 思路排序，然后输出前k个点。 代码1234567891011121314class Solution &#123;public: typedef long long LL; vector&lt;vector&lt;int&gt;&gt; kClosest(vector&lt;vector&lt;int&gt;&gt;&amp; points, int K) &#123; sort(points.begin(), points.end(), [](vector&lt;int&gt;&amp; a, vector&lt;int&gt;&amp; b)-&gt;bool&#123; // 按照到原点的距离从小到大排序 LL d1 = a[0] * a[0] + a[1] * a[1], d2 = b[0] * b[0] + b[1] * b[1]; return d1 &lt;= d2; &#125;); // 去掉多余的点 points.erase(points.begin() + K, points.end()); return points; &#125;&#125;;","categories":[],"tags":[]},{"title":"Leetcode122.买卖股票的最佳时机Ⅱ","slug":"lc-122","date":"2020-11-07T16:00:00.000Z","updated":"2020-11-08T09:28:09.692Z","comments":true,"path":"2020-11-08/lc-122/","link":"","permalink":"http://example.com/2020-11-08/lc-122/","excerpt":"","text":"题目122. 买卖股票的最佳时机 II 贪心 O(n)如果我们选择在第i天买入，在第j天卖出，我们的收益就是prices[j] - prices[i], 容易得出： 123prices[j] - prices[i]= prices[i + 1] - prices[i] + prices[i + 2] - prices[i + 1] + ... + prices[j] - prices[j - 1]= (prices[i + 1] - prices[i]) + (prices[i + 2] - prices[i + 1]) + ... + (prices[j] - prices[j - 1]) 也就是说，我们在两个第i天买入，第j天卖出所获得的收益就等于在第i天买入，第i+1天卖出之后再买入，然后第i+2天卖出再买入, 直到第j天至卖出不买入的收益。 那么我们如何最大化第i天到第j天的收入呢？对于任意prices[k + 1] - prices[k]，只能有三种情况： 小于0，也就是说卖出价格低于前一天买入价格，这样交易是亏钱的。 等于0，也就是说卖出价格等于前一天的买入价格，这样交易不亏不赚。 大于0，也就是说卖出价格大于前一天的买入价格，这样交易是赚钱的。 显然，我们只要抓住每次赚钱的机会，这样就可以保证我们可以赚到最多的钱了。 代码12345678910class Solution &#123;public: int maxProfit(vector&lt;int&gt;&amp; prices) &#123; int res = 0; for(int i = 0; i + 1 &lt; prices.size(); i ++ ) // 只选择赚钱的交易 if(prices[i + 1] &gt; prices[i]) res += prices[i + 1] - prices[i]; return res; &#125;&#125;; 动态规划我们还可以使用状态机动态规划来解决股票问题。我们可以设定两个状态：状态0：未持有股票和状态1: 持有股票;两个状态的状态表示以及状态转移： 如果我们未持有股票，我们就需要prices[i]去获得股票，如果我们持有股票，我们就可以卖掉获得prices[i]。因为一开始我们是未持有股票的，所以状态机的入口是状态0. 代码12345678910111213141516171819class Solution &#123;public: int maxProfit(vector&lt;int&gt;&amp; prices) &#123; int n = prices.size(); // dp[i][j]：第i天，处于状态j可以获得的最大收益 vector&lt;vector&lt;int&gt;&gt; dp(n + 1, vector&lt;int&gt;(2)); // 因为入口是状态0，所以将第0天状态1设置为-2e9(负无穷)，使其只能从状态0转移。 dp[0][1] = -2e9; // 枚举每一天 for(int i = 1; i &lt;= n; i ++ )&#123; // 状态转移方程是根据状态机中的边写出来的 // 第i天，未持有股票获得的最大收益 = max(第i - 1天未持有股票的最大收益，第i - 1天持有股票并卖出股票) dp[i][0] = max(dp[i - 1][0], dp[i - 1][1] + prices[i - 1]); // 第i天，持有股票获得的最大收益 = max(第i - 1天持有股票的最大收益，第i - 1天未持有股票并买入股票) dp[i][1] = max(dp[i - 1][1], dp[i - 1][0] - prices[i - 1]); &#125; return dp[n][0]; &#125;&#125;;","categories":[],"tags":[]},{"title":"Leetcode327. 区间和的个数","slug":"lc-327","date":"2020-11-07T16:00:00.000Z","updated":"2020-11-08T08:31:37.159Z","comments":true,"path":"2020-11-08/lc-327/","link":"","permalink":"http://example.com/2020-11-08/lc-327/","excerpt":"","text":"题目327. 区间和的个数思路 &amp; 代码要求一个数组的某一区间和，我们可以利用前缀和算法。 设：数组nums是下标从1~n的数组，那么他的前缀和就是sum[i] = nums[1] + nums[2] + nums[3] + ... + nums[i]，我们可以用下面的代码实现： 1for(int i = 1; i &lt;= n; i ++ ) sum[i] = sum[i - 1] + nums[i]; 因为本题的nums数组是从0开始的，所以我们可以稍微修改一下（sum数组仍然从1开始）： 1for(int i = 1; i &lt;= n; i ++ ) sum[i] = sum[i - 1] + nums[i - 1]; 那么有了sum数组，我们就可以在O(1)的时间复杂度查询到任意区间内的区间和： 1sum[j : i] = sum[i] - sum[j - 1] = nums[j] + nums[j + 1] + ... + nums[i - 1] + nums[i] 本体的题意是找到区间[i, j]的区间和sum[j : i]和在给定范围的区间个数，也就是说，找到所有满足下列公式的区间： 123lower &lt;= sum[i] - sum[j] &lt;= upper; 1 &lt;= i &lt;= n, 0 &lt;= j &lt;= i - 1;等价变换：sum[i] - upper &lt;= sum[j] &lt;= sum[i] - lower; ---- 公式1 所以，我们的任务就是对于每一个sum[i], 找到满足公式1的sum[j]的个数; 我们可以通过这个思路写出一个时间复杂度为O(n^2)的算法,代码如下： 朴素版 O(n^2)12345678910111213141516171819class Solution &#123;public: typedef long long LL; int countRangeSum(vector&lt;int&gt;&amp; nums, int lower, int upper) &#123; int n = nums.size(); vector&lt;LL&gt; sum(n + 1); // 求区间和 for(int i = 1; i &lt;= n; i ++) sum[i] = sum[i - 1] + nums[i - 1]; int res = 0; // 对于每一个sum[i], 找到满足`公式1`的sum[j]的个数 for(int i = 1; i &lt;= n; i ++)&#123; LL a = sum[i] - upper, b = sum[i] - lower; for(int j = 0; j &lt; i; j ++ ) if(a &lt;= sum[j] &amp;&amp; sum[j] &lt;= b) res ++ ; &#125; return res; &#125;&#125;; 但是这样做会TLE，所以我们就要通过一些方法优化一下时间复杂度。我们可以想象一个容器，我们可以把数插入进去，然后在很短的时间内，查询到这个容器中有多少个数是在给定范围的。如果存在这样一个数据结构，我们就可以很方便的遍历前缀和数组sum,然后查询容器中有多少数是在范围[sum[i] - upper, sum[i] - lower]中的，然后我们再将sum[i]插入到容器中去。 要实现这样的数据结构，我们需要学习离散化和树状数组或线段树算法。 树状数组 O(nlogn)以下内容涉及离散化和树状数组的相关知识 将sum[i], sum[i] - upper - 1, sum[i] - lower离散化； 使用一个抽象的数组a，维护数组sum中的元素出现的次数。 使用树状数组，维护数组a的前缀和，使得我们可以在O(logn)的时间复杂度内，将sum[i]出现的次数+1， 查询有多少sum[j]是在范围[sum[i] - upper, sum[i] - lower]内的。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152class Solution &#123;public: typedef long long LL; vector&lt;LL&gt; sum, vals, tr; int n; // 离散化 int get(LL x)&#123; int l = 0, r = vals.size() - 1; while(l &lt; r)&#123; int mid = (l + r) / 2; if(vals[mid] &gt;= x) r = mid; else l = mid + 1; &#125; return l + 1; &#125; // 树状数组的基本操作 int lowerbit(int x)&#123; return x &amp; -x; &#125; // 单点修改 void add(int x, int v)&#123; for(int i = x; i &lt; tr.size(); i += lowerbit(i)) tr[i] += v; &#125; // 区间查询 int query(int x)&#123; int res = 0; for(int i = x; i; i -= lowerbit(i)) res += tr[i]; return res; &#125; int countRangeSum(vector&lt;int&gt;&amp; nums, int lower, int upper) &#123; n = nums.size(); sum = vector&lt;LL&gt;(n + 1); // 将&#x27;sum[i], sum[i] - upper - 1, sum[i] - lower&#x27;离散化； for(int i = 0; i &lt;= n; i ++)&#123; if(i) sum[i] = sum[i - 1] + nums[i - 1]; vals.push_back(sum[i]); vals.push_back(sum[i] - upper - 1); vals.push_back(sum[i] - lower); &#125; sort(vals.begin(), vals.end()); vals.erase(unique(vals.begin(), vals.end()), vals.end()); // 树状数组 tr.resize(vals.size() + 1); int res = 0; for(int i = 0; i &lt;= n; i ++ )&#123; res += query(get(sum[i] - lower)) - query(get(sum[i] - upper - 1)); add(get(sum[i]), 1); &#125; return res; &#125;&#125;; 线段树 O(nlogn)我们使用的是不带懒标记的线段树，实现的功能也是单点修改，区间查询。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081class Solution &#123;public: typedef long long LL; typedef struct&#123; int l, r, sum; &#125;Node; vector&lt;Node&gt; tr; vector&lt;LL&gt; sum, vals; int n; // 离散化 int get(LL x)&#123; int l = 0, r = vals.size() - 1; while(l &lt; r)&#123; int mid = l + r &gt;&gt; 1; if(vals[mid] &gt;= x) r = mid; else l = mid + 1; &#125; return l + 1; &#125; // 线段树基本操作 void pushup(int u)&#123; tr[u].l = tr[u &lt;&lt; 1].l, tr[u].r = tr[u &lt;&lt; 1 | 1].r; tr[u].sum = tr[u &lt;&lt; 1].sum + tr[u &lt;&lt; 1 | 1].sum; &#125; // 建树 void build(int u, int l, int r)&#123; if(l == r)&#123; tr[u].l = tr[u].r = l; return; &#125; int mid = (l + r) &gt;&gt; 1; build(u &lt;&lt; 1, l, mid); build(u &lt;&lt; 1 | 1, mid + 1, r); pushup(u); &#125; // 区间查询 int query(int u, int l, int r)&#123; if(l &lt;= tr[u].l &amp;&amp; tr[u].r &lt;= r) return tr[u].sum; int mid = tr[u].l + tr[u].r &gt;&gt; 1; int res = 0; if(mid &gt;= l) res += query(u &lt;&lt; 1, l, r); if(mid &lt; r) res += query(u &lt;&lt; 1 | 1, l, r); return res; &#125; // 单点修改 void modify(int u, int x, int v)&#123; if(tr[u].l == x &amp;&amp; tr[u].r == x)&#123; tr[u] = &#123;x, x, tr[u].sum + v&#125;; return; &#125; int mid = tr[u].l + tr[u].r &gt;&gt; 1; if(x &lt;= mid) modify(u &lt;&lt; 1, x, v); else modify(u &lt;&lt; 1 | 1, x, v); pushup(u); &#125; int countRangeSum(vector&lt;int&gt;&amp; nums, int lower, int upper) &#123; n = nums.size(); sum.resize(n + 1); // 求前缀和，并且离散化 for(int i = 0; i &lt;= n; i ++ )&#123; if(i) sum[i] = sum[i - 1] + nums[i - 1]; vals.push_back(sum[i]); vals.push_back(sum[i] - upper); vals.push_back(sum[i] - lower); &#125; sort(vals.begin(), vals.end()); vals.erase(unique(vals.begin(), vals.end()), vals.end()); tr.resize(vals.size() * 4 + 10); // 建树 build(1, 1, vals.size()); int res = 0; // 遍历，求结果并插入到线段树中。 for(int i = 0; i &lt;= n; i ++ )&#123; res += query(1, get(sum[i] - upper), get(sum[i] - lower)); modify(1, get(sum[i]), 1); &#125; return res; &#125;&#125;;","categories":[],"tags":[]},{"title":"1356. 根据数字二进制下 1 的数目排序","slug":"lc-1356","date":"2020-11-05T16:00:00.000Z","updated":"2020-11-06T07:00:16.143Z","comments":true,"path":"2020-11-06/lc-1356/","link":"","permalink":"http://example.com/2020-11-06/lc-1356/","excerpt":"","text":"题目1356. 根据数字二进制下 1 的数目排序思路统计每个数对应的二进制数的1的个数，然后根据1的个数排序即可。 怎么统计二进制数中1的个数呢？我们可以遍历这个数的每一位，如果这位是1，就计数。这样就可以得到结果了。 代码12345int f(int x)&#123; int cnt = 0; for(int i = 0; i &lt; 32; i ++ ) cnt += (x &gt;&gt; i) &amp; 1; return cnt;&#125; 这样每个数都要遍历32位，在python中一个数可能也不止32位，我们如何得到这个数的1的个数呢？ 可以使用lowerbit算法，lowerbit是一个常用的算法，可以用来得到一个数的最低一位1所在的位置，比如说 $ 6d = 110b $ ，6的最低一位1出现在第二位，lowerbit算法就会返回 $ 10b = 2d $ (b和d分别表示二进制和十进制)。同理 $ lowerbit(8) = 8, lowerbit(12) = 4, …. $ lowerbit算法的代码很简单，只有一行具体的证明请同学们自己思考或者搜索。 代码123int lowerbit(int x)&#123; return x &amp; -x;&#125; 通过lowerbit算法我们如何得到一个数的二进制数中1的个数呢？其实很简单，只要每次找到最低一位1，然后计数，将这个最低一位1从数中减去，直到数为0即可. 代码12345int f(int x)&#123; int cnt = 0; while(x) x -= lowerbit(x), cnt ++ ; return cnt;&#125; 现在我们得到了求一个数的二进制数中1的个数的算法，我们要求数组arr中的所有数的二进制数1的个数，只需要遍历即可。 那么我们可不可以继续优化这个算法的时间复杂度呢？我们可以通过动态规划来进行优化, 给定一个数x，如果我们已知 $ x - lowerbit(x) $ 中有多少个1，那么x就比 $ x - lowerbit(x) $ 多一个1.状态转移方程： f(x) = f(x - lowerbit(x)) + 1 代码12345vector&lt;int&gt; cnt; // cnt[i]记录数字i对应二进制数中1的个数int f(int x)&#123; if(x == 0 || cnt[x] != 0) return cnt[x]; //这个数之前计算过 return cnt[x] = f(x - lowerbit(x)) + 1; // 状态转移方程&#125; 好的，以上就是对于计算一个二进制数中1的个数的算法的优化过程。算法还是挺有趣的，大家加油哦~ 代码123456789101112131415161718192021class Solution &#123;public: vector&lt;int&gt; cnt; // cnt[i]记录数字i对应二进制数中1的个数 // 计算数x对应的二进制数中1的个数 int f(int x)&#123; if(!x || cnt[x] != 0) return cnt[x]; return cnt[x] = f(x - (x &amp; -x)) + 1; &#125; vector&lt;int&gt; sortByBits(vector&lt;int&gt;&amp; arr) &#123; cnt = vector&lt;int&gt;(10010); for(auto t : arr) f(t); sort(arr.begin(), arr.end(), [](int a, int b)-&gt;bool&#123; // 如果两个数a和b对应的二进制数中1的个数不同,1的个数少的在前面 if(cnt[a] != cnt[b]) return cnt[a] &lt; cnt[b]; // 如果相同，小的在前面 return a &lt; b; &#125;); return arr; &#125;&#125;; 附 lambda表达式lambda表达式：很多语言都有的语法糖，可以用来创建匿名函数，简化函数的书写。在sort函数中经常使用，因为我对C++的了解也仅限于做题。所以大家自行搜索吧，hhhh。附上一篇我觉得还可以的博客。 lambda表达式","categories":[],"tags":[]},{"title":"LeetCode127.单词接龙","slug":"lc-127","date":"2020-11-04T16:00:00.000Z","updated":"2020-11-05T09:43:20.966Z","comments":true,"path":"2020-11-05/lc-127/","link":"","permalink":"http://example.com/2020-11-05/lc-127/","excerpt":"","text":"题目127. 单词接龙思路使用广度优先搜索，给定一个单词，搜索其所有可能得到的单词，如果变化后单词在给定的单词集合中，就将其加入到队列中，直到找到最终的单词或者队列为空。 代码1234567891011121314151617181920212223242526272829303132333435class Solution &#123;public: int ladderLength(string beginWord, string endWord, vector&lt;string&gt;&amp; wordList) &#123; // 记录给定的单词集合 unordered_set&lt;string&gt; st; for(auto s : wordList) st.insert(s); // 记录每个单词距离beginword的距离 // 就是beginword改变多少单词可以得到这个单词 unordered_map&lt;string, int&gt; dict; // 起始距离设为1 dict.insert(&#123;beginWord, 1&#125;); // bfs队列 queue&lt;string&gt; q; q.push(beginWord); while(q.size())&#123; auto t = q.front(); q.pop(); // 如果找到答案了，返回结果 if(t == endWord) return dict[t]; // 所有改变一次能得到的单词 for(int i = 0; i &lt; t.size(); i ++ )&#123; auto r = t; for(char c = &#x27;a&#x27;; c &lt;= &#x27;z&#x27;; c ++ )&#123; r[i] = c; // 如果这个单词在集合中，且之前没有被访问过 if(st.count(r) &amp;&amp; !dict.count(r))&#123; q.push(r); dict[r] = dict[t] + 1; &#125; &#125; &#125; &#125; // 没有答案 return 0; &#125;&#125;;","categories":[],"tags":[]},{"title":"57. 插入区间","slug":"lc-57","date":"2020-11-03T16:00:00.000Z","updated":"2020-11-04T04:58:19.907Z","comments":true,"path":"2020-11-04/lc-57/","link":"","permalink":"http://example.com/2020-11-04/lc-57/","excerpt":"","text":"题目57. 插入区间思路这道题就是一个区间合并的题，首先给定一组有序的区间，和一个要插入的区间，我们可以把这组区间分成三类 在要插入的区间左边，没有交集的区间 和给定区间可以合并成一个区间的区间 最后是剩下的和合并后的区间没有交集的区间。 设：给定区间的左右断点分别为l和r。 对于三类区间： 首先，因为给定的区间都是有序的，所以我们可以先把这些数组加入到答案中，这些数组的都在给定区间的左边，所以他们的右端点是一定在给定区间的左端点的左边的，也就是$intervals[i][1] &lt; l$。 对于第二类区间，是我们要处理的区间，因为我们要将他们进行合并，先想一想他们具有什么样的特征，因为我们目前已经把$intervals[i][1] &lt; l$的区间都排除掉了，所以剩下的区间一定满足$intervals[i][1] &gt;= l$；然后在这些区间里面，什么样的区间是可以和我们给定的区间进行合并的呢？我们先将区间[l, r]初始化为给定的区间，然后我们将所有可以合并的区间合并进去。如果$intervals[i][0] &lt;= r$那么就表示，这个区间的左端点是在我们给定的区间内的，我们就更新区间[l, r] 对于第三类区间，和第一类相同，直接加入到答案里面。 代码1234567891011121314151617181920class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; insert(vector&lt;vector&lt;int&gt;&gt;&amp; intervals, vector&lt;int&gt;&amp; newInterval) &#123; vector&lt;vector&lt;int&gt;&gt; res; // 初始化要合并的区间 int l = newInterval[0], r = newInterval[1]; int i = 0; // 下面将区间分成三类，挨个遍历 // 没有交集的区间 while(i &lt; intervals.size() &amp;&amp; intervals[i][1] &lt; l) res.push_back(intervals[i ++ ]); // 可以合并的区间 while(i &lt; intervals.size() &amp;&amp; intervals[i][0] &lt;= r) l = min(l, intervals[i][0]), r = max(r, intervals[i][1]), i ++ ; res.push_back(&#123;l, r&#125;); // 没有交集的区间 while(i &lt; intervals.size()) res.push_back(intervals[i ++ ]); return res; &#125;&#125;;","categories":[],"tags":[],"author":"Lituo"},{"title":"941. 有效的山脉数组","slug":"lc-941","date":"2020-11-02T16:00:00.000Z","updated":"2020-11-02T23:51:05.676Z","comments":true,"path":"2020-11-03/lc-941/","link":"","permalink":"http://example.com/2020-11-03/lc-941/","excerpt":"","text":"题目941. 有效的山脉数组思路模拟题，扫描一遍数组，如果是单调升+单调降的话，就返回true，否则返回false 代码12345678910class Solution &#123;public: bool validMountainArray(vector&lt;int&gt;&amp; A) &#123; int i = 0; while(i + 1 &lt; A.size() &amp;&amp; A[i] &lt; A[i + 1]) i ++ ; if(i == 0 || i == A.size() - 1) return false; while(i + 1 &lt; A.size() &amp;&amp; A[i] &gt; A[i + 1]) i ++ ; return i == A.size() - 1; &#125;&#125;;","categories":[],"tags":[],"author":"Lituo"},{"title":"349. 两个数组的交集","slug":"lc-349","date":"2020-11-02T00:32:11.000Z","updated":"2020-11-02T00:33:28.785Z","comments":true,"path":"2020-11-02/lc-349/","link":"","permalink":"http://example.com/2020-11-02/lc-349/","excerpt":"","text":"题目349. 两个数组的交集思路使用一个hash表，存储一个数组的所有元素，然后再遍历另一个数组，如果hash表中存在这个元素，就把它加入到答案中。 因为答案是没有重复的，所以在遍历另一个数组的时候，在向答案数组中添加元素的时候，我们就把这个元素从hash表中删除，这样就不会有重复的元素了。 代码123456789101112131415161718192021class Solution &#123;public: vector&lt;int&gt; intersection(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) &#123;​ vector&lt;int&gt; res;​ unordered_set&lt;int&gt; st;​ for(auto t : nums1) st.insert(t);​ for(auto t : nums2)​ if(st.count(t)) st.erase(t), res.push_back(t);​ return res; &#125;&#125;;","categories":[],"tags":[]}],"categories":[],"tags":[]}