{"meta":{"title":"醒来","subtitle":"因为热爱","description":"","author":"LiTuo","url":"http://example.com","root":"/"},"pages":[],"posts":[{"title":"Leetcode389. 找不同","slug":"lc-389","date":"2020-12-17T16:00:00.000Z","updated":"2020-12-18T02:27:23.803Z","comments":true,"path":"lc-389/","link":"","permalink":"http://example.com/lc-389/","excerpt":"","text":"题目389. 找不同 算法字符哈希，比较两个单词中哪个字符是前一个字符没出现过或者出现次数+1的。 代码C++1234567891011class Solution &#123;public: char findTheDifference(string s, string t) &#123; unordered_map&lt;char, int&gt; mp; for(auto c : s) mp[c] ++ ; for(auto c : t) if(mp[c] == 0) return c; else mp[c] -- ; return &#x27; &#x27;; &#125;&#125;; Java1234567891011class Solution &#123; public char findTheDifference(String s, String t) &#123; Map&lt;Character, Integer&gt; mp = new HashMap&lt;&gt;(); for(char c : s.toCharArray()) mp.put(c, mp.get(c) == null ? 1 : mp.get(c) + 1); for(char c : t.toCharArray()) if(mp.get(c) == null || mp.get(c) == 0) return c; else mp.put(c, mp.get(c) - 1); return &#x27; &#x27;; &#125;&#125;","categories":[],"tags":[]},{"title":"Leetcode714. 买卖股票的最佳时机含手续费","slug":"lc-714","date":"2020-12-16T16:00:00.000Z","updated":"2020-12-17T06:56:21.384Z","comments":true,"path":"lc-714/","link":"","permalink":"http://example.com/lc-714/","excerpt":"","text":"题目714. 买卖股票的最佳时机含手续费 算法f[0][i]表示第i天没有持有股票，能获得的最大收益。f[1][i]表示第i天持有股票能获得的最大收益。所以第i天没有持有股票的最大收益就是从第i - 1天没有持有股票和持有股票然后交易后这两个状态转移过来的。 代码C++12345678910111213class Solution &#123;public: int maxProfit(vector&lt;int&gt;&amp; prices, int fee) &#123; int n = prices.size(); vector&lt;vector&lt;int&gt;&gt; f(2, vector&lt;int&gt;(n + 1, -2e9)); f[0][0] = 0; for(int i = 1; i &lt;= n; i ++ )&#123; f[0][i] = max(f[0][i - 1], f[1][i - 1] + prices[i - 1] - fee); f[1][i] = max(f[1][i - 1], f[0][i - 1] - prices[i - 1]); &#125; return max(f[0][n], f[1][n]); &#125;&#125;; Java12345678910111213class Solution &#123; public int maxProfit(int[] prices, int fee) &#123; int n = prices.length; int[][] f = new int[2][n + 1]; f[0][0] = 0; f[1][0] = (int)-2e9; for(int i = 1; i &lt;= n; i ++ )&#123; f[0][i] = Math.max(f[0][i - 1], f[1][i - 1] + prices[i - 1] - fee); f[1][i] = Math.max(f[1][i - 1], f[0][i - 1] - prices[i - 1]); &#125; return Math.max(f[0][n], f[1][n]); &#125;&#125;","categories":[],"tags":[]},{"title":"Leetcode290. 单词规律","slug":"lc-290","date":"2020-12-15T16:00:00.000Z","updated":"2020-12-15T23:37:58.470Z","comments":true,"path":"lc-290/","link":"","permalink":"http://example.com/lc-290/","excerpt":"","text":"题目290. 单词规律 算法把字符和单词进行双射映射，如果两者一一对应就返回true， 否则返回false. 代码C++1234567891011121314151617181920class Solution &#123;public: bool wordPattern(string pattern, string s) &#123; unordered_map&lt;char, string&gt; ps; unordered_map&lt;string, char&gt; sp; int i = 0; for(auto c : pattern)&#123; if(i &gt;= s.size()) return false; string word; while(i &lt; s.size() &amp;&amp; s[i] != &#x27; &#x27;) word += s[i ++ ]; if(!ps.count(c)) ps[c] = word; if(ps[c] != word) return false; if(!sp.count(word)) sp[word] = c; if(sp[word] != c) return false; i ++ ; &#125; if(i &lt; s.size()) return false; return true; &#125;&#125;; Java1234567891011121314151617class Solution &#123; public boolean wordPattern(String pattern, String s) &#123; String[] words = s.split(&quot; &quot;); if(pattern.length() != words.length) return false; HashMap&lt;Character, String&gt; ps = new HashMap(); HashMap&lt;String, Character&gt; sp = new HashMap(); for(int i = 0; i &lt; words.length; i ++ )&#123; if(!ps.containsKey(pattern.charAt(i))) ps.put(pattern.charAt(i), words[i]); // 注意字符串的比较 if(!ps.get(pattern.charAt(i)).equals(words[i])) return false; if(!sp.containsKey(words[i])) sp.put(words[i], pattern.charAt(i)); if(sp.get(words[i]) != pattern.charAt(i)) return false; &#125; return true; &#125;&#125;","categories":[],"tags":[]},{"title":"Leetcode738. 单调递增的数字","slug":"lc-738","date":"2020-12-14T16:00:00.000Z","updated":"2020-12-15T00:26:17.061Z","comments":true,"path":"lc-738/","link":"","permalink":"http://example.com/lc-738/","excerpt":"","text":"题目738. 单调递增的数字 算法代码C++12345678910111213141516171819class Solution &#123;public: int monotoneIncreasingDigits(int N) &#123; string num = to_string(N); num = &#x27;0&#x27; + num; int i = 0; while(i &lt; num.size() - 1 &amp;&amp; num[i] &lt;= num[i + 1]) i ++ ; if(i &lt; num.size() - 1)&#123; while(true)&#123; num[i] -- ; if(num[i] &gt;= num[i - 1]) break; i -- ; &#125; i ++ ; while(i &lt; num.size()) num[i ++ ] = &#x27;9&#x27;; &#125; return stoi(num); &#125;&#125;; Java123456789101112131415161718192021222324class Solution &#123; public int monotoneIncreasingDigits(int N) &#123; StringBuilder num = new StringBuilder(); num.setLength(10); for(int i = 9; i &gt;= 0; i -- )&#123; num.setCharAt(i, (char)(N % 10 + &#x27;0&#x27;)); N /= 10; &#125; int i = 0; while(i + 1 &lt; 10 &amp;&amp; num.charAt(i) &lt;= num.charAt(i + 1)) i ++ ; if(i + 1 &lt; 10)&#123; while(true)&#123; num.setCharAt(i, (char)(num.charAt(i) - 1)); if(num.charAt(i) &gt;= num.charAt(i - 1)) break; i -- ; &#125; i ++ ; while(i &lt; 10) num.setCharAt(i ++ , &#x27;9&#x27;); &#125; int res = 0; for(i = 0; i &lt; 10; i ++ ) res = res * 10 + (num.charAt(i) - &#x27;0&#x27;); return res; &#125;&#125;","categories":[],"tags":[]},{"title":"Leetcode 376. 摆动序列","slug":"lc-376","date":"2020-12-13T16:00:00.000Z","updated":"2020-12-13T23:00:17.542Z","comments":true,"path":"lc-376/","link":"","permalink":"http://example.com/lc-376/","excerpt":"","text":"题目376. 摆动序列 算法动态规划刚开始想到的是最长上升子序列模型，遍历每个数字的时候遍历其之前的所有数字，然后根据前面的摆动序列的长度来更新当前数字的摆动序列长度。 具体来说，对于数字nums[i],遍历之前的每个数字nums[j],如果nums[i] &lt; nums[j], 那么最后两个数就是上升的，把nums[i]加进原来最后两个数是下降的序列中即可，状态转移方程： 12345// f[0][i]表示以nums[i]为结尾最后两个数是上升的，最长摆动序列的长度。// f[1][i]表示以nums[i]为结尾最后两个数是下降的，最长摆动序列的长度。f[0][i] = max(f[0][i], f[1][i - 1] + 1);// 同理，如果`nums[i] &lt; nums[j]`:f[1][i] = max(f[1][i], f[0][i - 1] + 1); 代码C++12345678910111213141516171819202122class Solution &#123;public: int wiggleMaxLength(vector&lt;int&gt;&amp; nums) &#123; int n = nums.size(); if(!n) return 0; // f[0][i]: 以nums[i]为结尾，差值最后一个数大于零的序列的最长长度 // f[1][i]: 以nums[i]为结尾，差值最后一个数小于零的序列的最长长度 vector&lt;vector&lt;int&gt;&gt; f(2, vector&lt;int&gt;(n)); f[0][0] = 1; f[1][0] = 1; int res = 1; for(int i = 1; i &lt; n; i ++ ) for(int j = 0; j &lt; i; j ++ ) if(nums[i] &gt; nums[j])&#123; // 最后两个数上升 f[0][i] = max(f[0][i], f[1][j] + 1); res = max(res, f[0][i]); &#125;else if(nums[i] &lt; nums[j])&#123; // 最后两个数下降 f[1][i] = max(f[1][i], f[0][j] + 1); res = max(res, f[1][i]); &#125; return res; &#125; Java12345678910111213141516171819202122class Solution &#123; public int wiggleMaxLength(int[] nums) &#123; int n = nums.length; if(n == 0) return 0; // f[0][i]: 以nums[i]为结尾，差值最后一个数大于零的序列的最长长度 // f[1][i]: 以nums[i]为结尾，差值最后一个数小于零的序列的最长长度 int[][] f = new int[2][n]; f[0][0] = f[1][0] = 1; int res = 1; for(int i = 1; i &lt; n; i ++ )&#123; for(int j = 0; j &lt; i; j ++ ) if(nums[i] &gt; nums[i - 1])&#123; // 差值最后一个数大于零的序列 f[0][i] = Math.max(f[0][i], f[1][j] + 1); res = Math.max(res, f[0][i]); &#125;else if(nums[i] &lt; nums[j])&#123; // 差值最后一个数小于零的序列 f[1][i] = Math.max(f[1][i], f[0][j] + 1); res = Math.max(res, f[1][i]); &#125; &#125; return res; &#125;&#125; 还有一种动态规划的算法只要O(n), 就在官方题解里面，但是我一直没怎么想明白，以后再补吧 贪心贪心的算法也很简单，将相邻重复元素去重，计算这个去重数组中的极值个数，再加上个端点，就是想要的答案了。 如果要证明的话，可以用调整法，任意选取一个最优解，我们在这个最优解里面任选一个点，我们都可以把他调整到最近的极大值或者是极小值，也就和我们所选取的答案相同了。 代码C++1234567891011121314class Solution &#123;public: int wiggleMaxLength(vector&lt;int&gt;&amp; nums) &#123; nums.erase(unique(nums.begin(), nums.end()), nums.end()); int n = nums.size(); if(n &lt;= 2) return n; int res = 2; // 两个端点值 for(int i = 1; i + 1 &lt; n; i ++ )&#123; int a = nums[i - 1], b = nums[i], c = nums[i + 1]; if(b &lt; a &amp;&amp; b &lt; c || b &gt; a &amp;&amp; b &gt; c) res ++ ; // b是极小值或者极大值 &#125; return res; &#125;&#125;; Java12345678910111213141516class Solution &#123; public int wiggleMaxLength(int[] nums) &#123; if(nums.length == 0) return 0; int n = 0; for(int i = 1; i &lt; nums.length; i ++ ) if(nums[i] != nums[n]) nums[++ n] = nums[i]; n ++ ; // 不连续相同的数字的个数 if(n &lt;= 2) return n; int res = 2; for(int i = 1; i + 1 &lt; n; i ++ )&#123; int a = nums[i - 1], b = nums[i], c = nums[i + 1]; if(b &lt; a &amp;&amp; b &lt; c || b &gt; a &amp;&amp; b &gt; c) res ++ ; &#125; return res; &#125;&#125;","categories":[],"tags":[]},{"title":"Leetcode 49. 字母异位词分组","slug":"lc-49","date":"2020-12-13T16:00:00.000Z","updated":"2020-12-13T22:24:20.040Z","comments":true,"path":"lc-49/","link":"","permalink":"http://example.com/lc-49/","excerpt":"","text":"题目49. 字母异位词分组 代码遍历每个单词，将其排序，这样每个字母异位词得到的排序结果都是相同的，再将原单词按照这个排序后的词进行hash，最后把字母异位词按照分组放到答案数组中即可。 C++123456789101112131415class Solution &#123;public: vector&lt;vector&lt;string&gt;&gt; groupAnagrams(vector&lt;string&gt;&amp; strs) &#123; unordered_map&lt;string, vector&lt;string&gt;&gt; mp; for(auto &amp;t : strs)&#123; string s = t; sort(s.begin(), s.end()); mp[s].push_back(t); &#125; vector&lt;vector&lt;string&gt;&gt; ans; for(auto &amp;[k, v] : mp) ans.push_back(v); return ans; &#125;&#125;; Java1234567891011121314151617class Solution &#123; public List&lt;List&lt;String&gt;&gt; groupAnagrams(String[] strs) &#123; Map&lt;String, ArrayList&lt;String&gt;&gt; mp = new HashMap(); for(String s : strs)&#123; char[] tmp = s.toCharArray(); Arrays.sort(tmp); String t = Arrays.toString(tmp); if(!mp.containsKey(t)) mp.put(t, new ArrayList()); ArrayList&lt;String&gt; lst = mp.get(t); lst.add(s); &#125; List&lt;List&lt;String&gt;&gt; ans = new ArrayList(); for(Map.Entry&lt;String, ArrayList&lt;String&gt;&gt; entry : mp.entrySet()) ans.add(entry.getValue()); return ans; &#125;&#125;","categories":[],"tags":[]},{"title":"Leetcode 217. 存在重复元素","slug":"lc-217","date":"2020-12-12T16:00:00.000Z","updated":"2020-12-12T23:53:03.821Z","comments":true,"path":"lc-217/","link":"","permalink":"http://example.com/lc-217/","excerpt":"","text":"题目217. 存在重复元素 算法用一个哈希表，存储遍历过的元素，如果当前遍历的元素在哈希表中，就返回false。如果全部元素都是不同的，返回true。 代码C++12345678910class Solution &#123;public: bool containsDuplicate(vector&lt;int&gt;&amp; nums) &#123; unordered_set&lt;int&gt; st; for(auto t : nums) if(st.count(t)) return true; else st.insert(t); return false; &#125;&#125;; Java123456789class Solution &#123; public boolean containsDuplicate(int[] nums) &#123; Set&lt;Integer&gt; st = new HashSet(); for(int t : nums) if(st.contains(t)) return true; else st.add(t); return false; &#125;&#125;","categories":[],"tags":[]},{"title":"Leetcode 649. Dota2 参议院","slug":"lc-649","date":"2020-12-10T16:00:00.000Z","updated":"2020-12-11T23:19:17.813Z","comments":true,"path":"lc-649/","link":"","permalink":"http://example.com/lc-649/","excerpt":"","text":"题目649. Dota2 参议院 算法用两个队列分别存入两个阵营要进行投票的时间，模拟投票的过程，按照时间顺序进行投票，轮到某一方的人进行投票就将另一方最早要进行投票的人ban掉, 然后自己再重新进入队列，直到某一方的队列为空。 代码C++123456789101112131415161718192021222324252627282930class Solution &#123;public: string predictPartyVictory(string s) &#123; queue&lt;int&gt; r, d; int n = s.size(); // 统计第一轮的投票时间 for(int i = 0; i &lt; n; i ++ )&#123; if(s[i] == &#x27;R&#x27;) r.push(i); else d.push(i); &#125; while(r.size() &amp;&amp; d.size())&#123; // 按照时间顺序进行投票 if(r.front() &lt; d.front())&#123; int t = r.front(); r.pop(); // 这里+n只是为了保证相对顺序，并不是准确的投票时间 r.push(t + n); // 另一方的人淘汰 d.pop(); &#125; else&#123; // 同理 int t = d.front(); d.pop(); d.push(t + n); r.pop(); &#125; &#125; if(r.size()) return &quot;Radiant&quot;; return &quot;Dire&quot;; &#125;&#125;; Java1234567891011121314151617181920212223242526class Solution &#123; public String predictPartyVictory(String s) &#123; Queue&lt;Integer&gt; r = new LinkedList(); Queue&lt;Integer&gt; d = new LinkedList(); int n = s.length(); // 统计第一轮的投票时间 for(int i = 0; i &lt; n; i ++ ) if(s.charAt(i) == &#x27;R&#x27;) r.offer(i); else d.offer(i); while(r.size() &gt; 0 &amp;&amp; d.size() &gt; 0) // 按照时间顺序进行投票 if(r.peek() &lt; d.peek())&#123; int t = r.poll(); // 这里+n只是为了保证相对顺序，并不是准确的投票时间 r.offer(t + n); // 另一方的人淘汰 d.poll(); &#125;else&#123; int t = d.poll(); d.offer(t + n); r.poll(); &#125; if(r.size() == 0) return &quot;Dire&quot;; return &quot;Radiant&quot;; &#125;&#125;","categories":[],"tags":[]},{"title":"Leetcode 860. 柠檬水找零","slug":"lc-860","date":"2020-12-09T16:00:00.000Z","updated":"2020-12-09T23:44:09.356Z","comments":true,"path":"lc-860/","link":"","permalink":"http://example.com/lc-860/","excerpt":"题目860. 柠檬水找零","text":"题目860. 柠檬水找零 算法收到钱之后看一下有没有足够的钱找零，有的话就找零，没有的话就返回false。 代码C++12345678910111213141516171819202122class Solution &#123;public: bool lemonadeChange(vector&lt;int&gt;&amp; bills) &#123; vector&lt;int&gt; change(5); for(auto t : bills)&#123; change[t / 5] ++ ; if(t == 10)&#123; // 找零5 if(change[1]) change[1] -- ; else return false; &#125; else if(t == 20)&#123; // 找零5 + 10 if(change[1] &amp;&amp; change[2]) change[1] -- , change[2] -- ; // 找零 5 * 3 else if(change[1] &gt;= 3) change[1] -= 3; else return false; &#125; &#125; return true; &#125;&#125;; Java123456789101112131415161718192021222324class Solution &#123; public boolean lemonadeChange(int[] bills) &#123; int[] change = new int[5]; for(int t : bills)&#123; change[t / 5] ++ ; if(t == 10)&#123; // 找零5 if(change[1] != 0) change[1] -- ; else return false; &#125; else if(t == 20)&#123; // 找零5 + 10 if(change[1] != 0 &amp;&amp; change[2] != 0)&#123; change[1] -- ; change[2] -- ; &#125; // 找零 5 * 3 else if(change[1] &gt;= 3) change[1] -= 3; else return false; &#125; &#125; return true; &#125;&#125;","categories":[],"tags":[]},{"title":"Leetcode 62. 不同路径","slug":"lc-62","date":"2020-12-08T16:00:00.000Z","updated":"2020-12-09T00:43:44.386Z","comments":true,"path":"lc-62/","link":"","permalink":"http://example.com/lc-62/","excerpt":"题目62. 不同路径","text":"题目62. 不同路径 算法动态规划 O(mn)设:f[i][j]是从(1, 1)格子走到(i, j)这个格子的所有不同走法的数量。很容易就能想到状态转移方程: f[i][j] = f[i - 1][j] + f[i][j - 1] , 分别表示从左边走过来和从上边走下来 代码C++1234567891011class Solution &#123;public: int uniquePaths(int m, int n) &#123; vector&lt;vector&lt;int&gt;&gt; f(m + 1, vector&lt;int&gt;(n + 1)); f[0][1] = 1; for(int i = 1; i &lt;= m; i ++ ) for(int j = 1; j &lt;= n; j ++) f[i][j] = f[i - 1][j] + f[i][j - 1]; return f[m][n]; &#125;&#125;; Java12345678910class Solution &#123; public int uniquePaths(int m, int n) &#123; int[][] f = new int[m + 1][n + 1]; f[0][1] = 1; for(int i = 1; i &lt;= m; i ++ ) for(int j = 1; j &lt;= n; j ++ ) f[i][j] = f[i - 1][j] + f[i][j - 1]; return f[m][n]; &#125;&#125; 组合数从(1, 1)格子走到(i, j)这个格子一共需要m + n - 2步，其中向右走n - 1步，向下走m - 1步。所以我们只要从m + n - 2步挑选n - 1个向下走就可以了，这是组合问题。 C_{m+n-2}^{m-1}=\\frac{(m+n-2)(m+n-3) \\cdots n}{(m-1) !}代码C++12345678910class Solution &#123;public: int uniquePaths(int m, int n) &#123; long long res = 1; for(int i = 1, j = n; i &lt;= m - 1; i ++ , j ++ ) res = res * j / i; return res; &#125;&#125;; Java12345678class Solution &#123; public int uniquePaths(int m, int n) &#123; long res = 1; for(int i = n, j = 1; j &lt;= m - 1; i ++ , j ++ ) res = res * i / j; return (int)res; &#125;&#125; 滚动数组优化滚动数组常用于优化动态规划问题的空间复杂度，可以将O(n^(m))空间复杂度的算法优化至O(n^(m - 1)), 适用场景是在更新当前状态时只会用到当前行和上一行的状态。对于今天的问题，我们可以尝试用滚动数组进行优化，得到一个空间复杂度是O(n)的算法。以下以C++代码为例，Java同理。 1234567891011class Solution &#123;public: int uniquePaths(int m, int n) &#123; vector&lt;vector&lt;int&gt;&gt; f(m + 1, vector&lt;int&gt;(n + 1)); f[0][1] = 1; for(int i = 1; i &lt;= m; i ++ ) for(int j = 1; j &lt;= n; j ++) f[i][j] = f[i - 1][j] + f[i][j - 1]; return f[m][n]; &#125;&#125;; 以上算法的一个空间复杂度是O(mn)，观察状态转移方程f[i][j] = f[i - 1][j] + f[i][j - 1] , 他在更新第i行的状态的时候，只用到上一行的第i个状态f[i - 1][j]和当前行的第j - 1个状态，所以，我们可以用滚动数组进行优化，将代码等价变形，用一个一维数组代替这个二维数组。 1234567891011121314class Solution &#123;public: int uniquePaths(int m, int n) &#123; // 直接去掉第一维 vector&lt;int&gt; f(n + 1); f[1] = 1; for(int i = 1; i &lt;= m; i ++ ) for(int j = 1; j &lt;= n; j ++) // 等价变换 f[j] = f[j] + f[j - 1]; // 在循环完毕后，f[n]就相当于原来的f[m][n] return f[n]; &#125;&#125;; 这就好像用一个窗口在二维数组上，每次更新状态都把这个窗口向下挪动。 还有一种更加直观的做法，就是将第一维的后面直接添加一个&amp;1，这样奇偶交替，也能达到滚动数组的效果。 12345678910111213class Solution &#123;public: int uniquePaths(int m, int n) &#123; // 这里只要奇偶两行即可 vector&lt;vector&lt;int&gt;&gt; f(2, vector&lt;int&gt;(n + 1)); // 在所有第一位后面都加上&amp;1 f[0 &amp; 1][1] = 1; for(int i = 1; i &lt;= m; i ++ ) for(int j = 1; j &lt;= n; j ++) f[i&amp;1][j] = f[i - 1&amp;1][j] + f[i&amp;1][j - 1]; return f[m&amp;1][n]; &#125;&#125;; 其他应用滚动数组的其他应用请参考：01背包问题和完全背包问题","categories":[],"tags":[]},{"title":"Leetcode 842. 将数组拆分成斐波那契序列","slug":"lc-842","date":"2020-12-07T16:00:00.000Z","updated":"2020-12-09T00:40:58.675Z","comments":true,"path":"lc-842/","link":"","permalink":"http://example.com/lc-842/","excerpt":"题目842. 将数组拆分成斐波那契序列","text":"题目842. 将数组拆分成斐波那契序列 算法DFS，枚举当前的数，如果当前数等于前两个数的和，就把他加入到答案数组，然后继续dfs。 代码C++123456789101112131415161718192021222324252627282930313233class Solution &#123;public: typedef long long LL; vector&lt;int&gt; nums; bool dfs(string&amp; s, int idx)&#123; if(idx == s.size()) return nums.size() &gt; 2; LL num = 0; for(int i = idx; i &lt; s.size(); i ++ )&#123; num = num * 10 + (s[i] - &#x27;0&#x27;); // 如果当前数大于INT的最大值，就停止枚举 if(num &gt; INT_MAX) break; // 如果当前数组中有两个及以上的数 if(nums.size() &gt; 1)&#123; LL sum = 0LL + nums.rbegin()[0] + nums.rbegin()[1]; // 如果当前数大于前两个数的和，停止枚举 if(num &gt; sum) break; // 如果当前数小于前两个数的和，继续枚举 if(num &lt; sum) continue; &#125; // 如果当前数等于前两个数的和，加入到当前数组，递归到下一层 nums.push_back(num); if(dfs(s, i + 1)) return true; nums.pop_back(); if(s[idx] == &#x27;0&#x27;) break; &#125; return false; &#125; vector&lt;int&gt; splitIntoFibonacci(string S) &#123; dfs(S, 0); return nums; &#125;&#125;; Java123456789101112131415161718192021222324252627282930313233class Solution &#123; List&lt;Integer&gt; nums = new ArrayList(); boolean dfs(String s, int idx)&#123; if(idx == s.length()) return nums.size() &gt; 2; long num = 0; for(int i = idx; i &lt; s.length(); i ++ )&#123; num = num * 10 + (int)(s.charAt(i) - &#x27;0&#x27;); if(nums.size() &gt; 1)&#123; // 如果溢出就会抛出异常 try&#123; int sum = nums.get(nums.size() - 1) + nums.get(nums.size() - 2); // 如果当前数小于前两个数的和，继续枚举 if(num &lt; sum) continue; // 如果当前数大于前两个数的和，停止枚举 if(num &gt; sum) break; &#125; catch(Exception e)&#123; break; &#125; &#125; // 如果当前数等于前两个数的和，加入到当前数组，递归到下一层 nums.add((int)num); if(dfs(s, i + 1)) return true; nums.remove(nums.size() - 1); if(s.charAt(idx) == &#x27;0&#x27;) break; &#125; return false; &#125; public List&lt;Integer&gt; splitIntoFibonacci(String S) &#123; dfs(S, 0); return nums; &#125;&#125;","categories":[],"tags":[]},{"title":"Leetcode 861. 翻转矩阵后的得分","slug":"lc-861","date":"2020-12-06T16:00:00.000Z","updated":"2020-12-07T07:41:37.458Z","comments":true,"path":"lc-861/","link":"","permalink":"http://example.com/lc-861/","excerpt":"","text":"题目861. 翻转矩阵后的得分 算法思路首先，我们对矩阵的某一行或者列进行“翻转”操作，这是顺序无关的操作，就是说，先翻第i行/列再翻第j行/列或者反过来都是一样的。然后对于任意一行/列，翻转两次就等于没有翻。所以问题并不在于我们应该怎样翻转，而在于我们选择翻不翻转某一行或列。这样问题就简单了很多。 对于每一行，因为1xxxxxx，一定是大于0xxxxxx的，所以如果某一行的最高位是0，那么我们就翻转它。而对于某一列，我们想要达到最大值，我们可以计算这一列0和1的个数，如果0的个数比较多，那么我们就翻转这一列，让这一列1的个数更多。 实际上我们可以不对数组进行修改，就可以统计0和1的个数。如果说原数组中的某一行的最高位是1，那么我们就不用进行翻转，这行的0和1也就是正常的0和1。而如果某一行的最高位是0，那么我们就会在翻转行的时候选择翻转这一行，然后这一行的0就变成了1，1就变成了0。 所以说对于某一行上的某一位，我们可以用如下真值表对某一列中1的个数进行计数(例如第一行：如果最高位是0，那么就要翻转这一行，如果第i位原本是0，翻转后就是1，计1。反之如果第i位是1，翻转后为0，就计0)： 最高位 第i位 结果 0 0 1 0 1 1 1 0 0 1 1 1 不难发现结果 = 1 - 最高位^第i位，其中&#39;^&#39;为异或。 代码C++1234567891011121314151617class Solution &#123;public: int matrixScore(vector&lt;vector&lt;int&gt;&gt;&amp; A) &#123; if(A.empty() || A[0].empty()) return 0; int n = A.size(), m = A[0].size(); // 将最高位都计为1 int res = n * pow(2, m - 1); for(int i = 1; i &lt; m; i ++ )&#123; // 统计翻转后1的个数 int cnt = 0; for(int j = 0; j &lt; n; j ++ ) cnt += 1 - (A[j][i] ^ A[j][0]); res += max(cnt, n - cnt) * pow(2, m - 1 - i); &#125; return res; &#125;&#125;; Java12345678910111213141516class Solution &#123; public int matrixScore(int[][] A) &#123; int n = A.length, m = A[0].length; // 将最高位都计为1 int res = n * (1 &lt;&lt; (m - 1)); for(int i = 1; i &lt; m; i ++ )&#123; int cnt = 0; for(int j = 0; j &lt; n; j ++ ) // 实际上这里统计的是0的个数，但是由于后面会取max(cnt, n - cnt)，所以不影响结果 // 可以与C++代码进行比较 cnt += A[j][0] ^ A[j][i]; res += (int)Math.max(cnt, n - cnt) * (1 &lt;&lt; (m - 1 - i)); &#125; return res; &#125;&#125;","categories":[],"tags":[]},{"title":"Leetcode118. 杨辉三角","slug":"lc-118","date":"2020-12-05T16:00:00.000Z","updated":"2020-12-05T22:32:48.501Z","comments":true,"path":"lc-118/","link":"","permalink":"http://example.com/lc-118/","excerpt":"题目118. 杨辉三角","text":"题目118. 杨辉三角 算法这道题就不解释了，直接做吧。 代码C++1234567891011121314class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; generate(int numRows) &#123; vector&lt;vector&lt;int&gt;&gt; res; for(int i = 0; i &lt; numRows; i ++ )&#123; vector&lt;int&gt; row(i + 1); row[0] = row[i] = 1; for(int j = 1; j &lt; i; j ++ ) row[j] = res[i - 1][j - 1] + res[i - 1][j]; res.push_back(row); &#125; return res; &#125;&#125;; Java12345678910111213class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; generate(int numRows) &#123; List&lt;List&lt;Integer&gt;&gt; res = new ArrayList(); for(int i = 0; i &lt; numRows; i ++ )&#123; List&lt;Integer&gt; row = new ArrayList(); for(int j = 0; j &lt;= i; j ++ ) if(j == 0 || j == i) row.add(1); else row.add(res.get(i - 1).get(j - 1) + res.get(i - 1).get(j)); res.add(row); &#125; return res; &#125;&#125;","categories":[],"tags":[]},{"title":"Leetcode 621. 任务调度器","slug":"lc-621","date":"2020-12-04T16:00:00.000Z","updated":"2020-12-05T12:10:46.186Z","comments":true,"path":"lc-621/","link":"","permalink":"http://example.com/lc-621/","excerpt":"题目621. 任务调度器","text":"题目621. 任务调度器 算法每一类任务会被分割成等大的时隙，然后在一个任务被调度以后，此后的n个时隙内不能再次被调度。所以在n + 1个时隙内一类任务只能出现一次。 步骤 找到每个任务需要被调用的最多次数maxCnt 统计被调用数是maxCnt的任务数m 答案就是max((maxCnt - 1) * (n + 1) + m, tasks.size()),其中tasks.size()是给定的序列长度。 思路 我们先找到一个任务，这个任务是需要被调用数最多的；然后我们将任务以n + 1个时隙划分成多行。显然每个同样的任务只能在同一行出现一次。假设这个任务是A，我们就应该按以下顺序安排任务A。 1 2 3 … n n + 1 1 A … 2 A … 3 A … … … … … … … … maxCnt - 1 A … maxCnt A … 此时我们的任务序列是[A，空，空，…, 空，空，A, A，空，空，…, 空，空，A], 横着数没有安排的位置就是’空’。 我们观察这个表格，除了最后一行，即使这些时隙没有被调度任务，那么他们也是空的，因为A和A之间要有n个冷却时隙。这些行的时隙数是(maxCnt - 1) * (n + 1)。 对于其他被调度数同样为maxCnt的任务，同样的相同的任务不能出现在同一行中，他们可以被安排在不同列中。 1 2 3 … n n + 1 1 A B … 2 A B … 3 A B … … … … … … … … maxCnt - 1 A B … maxCnt A B … 最后一行的被安排任务的时隙是m个，所以对于任意序列，它需要的最小时隙数量是(maxCnt - 1) * (n + 1)。 对于其他任务，我们按照他们的被调度数从大到小，在1~maxCnt - 1行按列填入表中就可以了，因为他们被调用数都是小于m的，所以这样调度不会出现冲突的情况。 1 2 3 … n n + 1 1 A B C … E G 2 A B C … F G 3 A B E … G … … … … … … … maxCnt - 1 A B E … G maxCnt A B … 如果(maxCnt - 1) * (n + 1) + m &lt; tasks.size(), 也就是给定的任务较多的时候，我们同样可以按照这个顺序进行调度，我们还可以把maxCnt这行的任务放到n + 2列上，多余任务也可以放在后面，因为这样每一行的列数都&gt;= n + 1, 是不会出现冲突的。 1 2 3 … n n + 1 n + 2 1 A B C … E F A 2 A B C … F F B 3 A B E … F G G … … … … … … … … maxCnt - 1 A B E … F G I 综上所述，我们想要的答案就是max((maxCnt - 1) * (n + 1) + m, tasks.size()) 。 代码C++1234567891011class Solution &#123;public: int leastInterval(vector&lt;char&gt;&amp; tasks, int n) &#123; unordered_map&lt;char, int&gt; cnt; int maxCnt = -2e9; for(auto c : tasks) cnt[c] ++ , maxCnt = max(maxCnt, cnt[c]); int m = 0; for(auto &amp;[c, cnt] : cnt) if(cnt == maxCnt) m ++ ; return max((maxCnt - 1) * (n + 1) + m, (int)tasks.size()); &#125;&#125;; Java123456789101112131415161718class Solution &#123; public int leastInterval(char[] tasks, int n) &#123; Map&lt;Character, Integer&gt; cnt = new HashMap(); int maxCnt = -0x3f3f3f3f; // 统计任务被调用数，找到每个任务需要被调用的最多次数maxCnt for(char c : tasks)&#123; if(!cnt.containsKey(c)) cnt.put(c, 0); int t = cnt.get(c) + 1; cnt.put(c, t); maxCnt = Math.max(maxCnt, t); &#125; int m = 0; // 统计被调用数是maxCnt的任务数m for(int t : cnt.values()) if(t == maxCnt) m ++ ; return Math.max((maxCnt - 1) * (n + 1) + m, tasks.length); &#125;&#125;","categories":[],"tags":[]},{"title":"Leetcode659. 分割数组为连续子序列","slug":"lc-659","date":"2020-12-03T16:00:00.000Z","updated":"2020-12-04T07:15:52.828Z","comments":true,"path":"lc-659/","link":"","permalink":"http://example.com/lc-659/","excerpt":"","text":"题目659. 分割数组为连续子序列 算法模拟 O(n)用两个哈希表，记录数组中数的个数和以x为结尾的队列的个数。然后遍历整个数组，将每个数加到队列里面，如果对于元素t有以t - 1为结尾的队列，则把t放到这个队列后面；如果没有，则新建一个队列，注意，因为每个队列的长度至少为3，所以要检查数组中是否还有 t + 1和 t + 2, 把这三个数一起放到队列中，也就是一个以t + 2为结尾的队列。 如果某个元素t，又没有以t - 1为结尾的队列，又不能和他后面的两个数创建一个新队列，则表示不能满足题意。 代码Java12345678910111213141516171819202122232425262728293031323334class Solution &#123; public boolean isPossible(int[] nums) &#123; Map&lt;Integer, Integer&gt; mp = new HashMap(); Map&lt;Integer, Integer&gt; que = new HashMap(); for(int t : nums)&#123; // 以t和t - 1为结尾的队列的数量初始化为0 que.put(t, 0); que.put(t - 1, 0); // 对nums中的元素进行计数 if(!mp.containsKey(t)) mp.put(t, 0); mp.put(t, mp.get(t) + 1); &#125; for(int t : nums)&#123; // 如果这个数被加入到队列中了，跳过 if(mp.get(t) == 0) continue; // 将这个数计数-1，准备放入队列 mp.put(t, mp.get(t) - 1); // 如果有以t - 1为结尾的队列 if(que.get(t - 1) != 0)&#123; que.put(t - 1, que.get(t - 1) - 1); que.put(t, que.get(t) + 1); &#125; // 如果t可以和t + 1 和 t + 2一起放入队列 else if(mp.containsKey(t + 1) &amp;&amp; mp.containsKey(t + 2) &amp;&amp; mp.get(t + 1) &gt; 0 &amp;&amp; mp.get(t + 2) &gt; 0)&#123; mp.put(t + 1, mp.get(t + 1) - 1); mp.put(t + 2, mp.get(t + 2) - 1); que.put(t + 2, que.get(t + 2) + 1); &#125; else return false; &#125; return true; &#125;&#125; C++12345678910111213141516171819class Solution &#123;public: bool isPossible(vector&lt;int&gt;&amp; nums) &#123; unordered_map&lt;int, int&gt; cnt, que; // 对数组中每个数进行计数 for(auto t : nums) cnt[t] ++ ; for(auto t : nums)&#123; // 如果这个数被提前加入队列 if(!cnt[t]) continue; // 如果有以t - 1为结尾的队列 if(que[t - 1]) que[t - 1] -- , que[t] ++ ; // 如果t可以和t + 1 和 t + 2一起放入队列 else if(cnt[t + 1] &amp;&amp; cnt[t + 2]) cnt[t + 1] -- , cnt[t + 2] -- , que[t + 2] ++ ; else return false; cnt[t] -- ; &#125; return true; &#125;&#125;;","categories":[],"tags":[]},{"title":"Leetcode204. 计数质数","slug":"lc-204","date":"2020-12-02T16:00:00.000Z","updated":"2020-12-03T11:58:08.827Z","comments":true,"path":"lc-204/","link":"","permalink":"http://example.com/lc-204/","excerpt":"题目204. 计数质数","text":"题目204. 计数质数 算法算法1 试除法筛质数O(n ^ 2)用试除法检查每个数是否是质数，如果是，就将答案加1。注意使用这种算法Java会TLE。 代码C++1234567891011121314class Solution &#123;public: bool isPrime(int x)&#123; for(int i = 2; i &lt;= x / i; i ++ ) if(x % i == 0) return false; return true; &#125; int countPrimes(int n) &#123; int res = 0; for(int i = 2; i &lt; n; i ++ ) if(isPrime(i)) res ++ ; return res; &#125;&#125;; Java12345678910111213class Solution &#123; boolean isPrime(int x)&#123; for(int i = 2; i &lt;= x / i; i ++ ) if(x % i == 0) return false; return true; &#125; public int countPrimes(int n) &#123; int res = 0; for(int i = 2; i &lt; n; i ++ ) if(isPrime(i)) res ++ ; return res; &#125;&#125; 算法2 朴素筛法 O(nlogn)使用一个数组记录这个数是否是素数。在遍历每个数的时候将这个数的倍数都筛选掉，因为素数不是任何数的倍数。在遍历的时候，如果这个数没有被遍历过，则表示这个数没有大于2的因数，这个数就是素数。 对于每个数j，我们第二层循环的次数是n / j，所以我们的总共需要循环 n / 2 + n / 3 + .... + n / (n - 1) = n(1 / 2 + 1 / 3 + ... + 1 / (n - 1)) ≈ n(logn + c), 后面是调和级数，近似等于logn。 代码C++1234567891011121314class Solution &#123;public: int countPrimes(int n) &#123; vector&lt;bool&gt; f(n); int res = 0; for(int i = 2; i &lt; n; i ++ )&#123; // 如果这个数没有被筛选过，答案+1 if(!f[i]) res ++ ; // 筛掉这个数的倍数 for(int j = i; j &lt; n; j += i) f[j] = true; &#125; return res; &#125;&#125;; Java12345678910111213class Solution &#123; public int countPrimes(int n) &#123; boolean[] f = new boolean[n]; int res = 0; for(int i = 2; i &lt; n; i ++ )&#123; // 如果这个数没有被筛选过，答案+1 if(!f[i]) res ++ ; // 筛掉这个数的倍数 for(int j = i; j &lt; n; j += i) f[j] = true; &#125; return res; &#125;&#125; 算法3 埃式筛法 O(nlog(logn))思路与算法2一致，只不过只筛掉素数的倍数，如果这个数不是素数，那么它的倍数也一定是其最小质因子的倍数，所以就不用再重复筛选了。 代码C++1234567891011121314class Solution &#123;public: int countPrimes(int n) &#123; vector&lt;bool&gt; f(n); int res = 0; for(int i = 2; i &lt; n; i ++ )&#123; // 如果这个数是合数（被筛掉过），则跳过 if(f[i]) continue; res ++ ; for(int j = i; j &lt; n; j += i) f[j] = true; &#125; return res; &#125;&#125;; Java12345678910111213class Solution &#123; public int countPrimes(int n) &#123; boolean[] f = new boolean[n]; int res = 0; for(int i = 2; i &lt; n; i ++ )&#123; // 如果这个数是合数（被筛掉过），则跳过 if(f[i]) continue; res ++ ; for(int j = i; j &lt; n; j += i) f[j] = true; &#125; return res; &#125;&#125; 算法4 线性筛法 O(n)在算法3中，某个数可能会有多个质因子，会被多次筛掉,如6这个数字就会被2和3筛掉两次。所以我们只要只用它的最小质因子筛掉就可以保证一个数只被晒一次了。 代码C++1234567891011121314151617181920class Solution &#123;public: int countPrimes(int n) &#123; vector&lt;bool&gt; f(n); vector&lt;int&gt; primes; for(int i = 2; i &lt; n; i ++ )&#123; if(!f[i]) primes.push_back(i); // 对于任意一个合数x，设他的最小质因子为y，则x / y &lt; x，x一定在之前就被筛过了 for(int j = 0; primes[j] &lt;= n / i; j ++ )&#123; // primes[j] &lt;= i的最小质因子，也就是primes[j] * i的最小质因子 f[primes[j] * i] = true; // 如果条件成立，那么primes[j]就是i的最小质因子 // i * primes[j + 1 : res]这些数的最小质因子 // 就是i的最小质因子而不是primes[j],所以停止筛选 if(i % primes[j] == 0) break; &#125; &#125; return primes.size(); &#125;&#125;; Java12345678910111213141516171819class Solution &#123; public int countPrimes(int n) &#123; boolean[] f = new boolean[n + 1]; int[] primes = new int[n]; int res = 0; for(int i = 2; i &lt; n; i ++ )&#123; if(!f[i]) primes[res ++ ] = i; for(int j = 0; primes[j] &lt;= n / i; j ++ )&#123; // 对于任意一个合数x，设他的最小质因子为y，则x / y &lt; x，x一定在之前就被筛过了 f[primes[j] * i] = true; // 如果条件成立，那么primes[j]就是i的最小质因子 // i * primes[j + 1 : res]这些数的最小质因子 // 就是i的最小质因子而不是primes[j],所以停止筛选 if(i % primes[j] == 0) break; &#125; &#125; return res; &#125;&#125;","categories":[],"tags":[]},{"title":"Leetcode321. 拼接最大数","slug":"lc-321","date":"2020-12-01T16:00:00.000Z","updated":"2020-12-02T12:59:57.914Z","comments":true,"path":"lc-321/","link":"","permalink":"http://example.com/lc-321/","excerpt":"题目321. 拼接最大数","text":"题目321. 拼接最大数 算法贪心 O(k * n^2)这道题的算法会用到Leetcode402. 移掉K位数字这道题的算法，如果不了解的请去看一下。有了402的基础，这道题就很简单了，先给出算法步骤： 枚举在nums1和nums2中分别取多少数i和j（i + j = k） 在nums1中取i个数得到数a，使得该数的字典序最大 在nums2中取j个数得到数b，使得该数的字典序最大 对a和b进行合并得到数c，使得概述的字典序最大 枚举过程中最大的数c就是我们想要的答案了。 所以这道题的核心问题就在于给定两个数a和b，我们怎么把这两个数按位的顺序合并能得到一个数c，使得它是合并的结果中字典序最大的数。 双指针算法步骤，类似于我们对两个有序的链表做归并所使用的算法： 初始化两个指针p和q，分别指向两个需要合并的数的最高位 如果指针p数的字典序大于指针q指向的数的字典序，那么将指针p指向的数的最高位接到答案数组的后面 否则，将指针q指向的数的最高位接到答案数组的后面 直到某一个数都接入到答案数组了，将另一个数的剩余部分加入到答案数组中 证明我不会，先放到这吧 代码C++12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849class Solution &#123;public: vector&lt;int&gt; maxNumber(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2, int k) &#123; int n = nums1.size(), m = nums2.size(); vector&lt;int&gt; res(k, -2e9); // 枚举答案数组中有多少元素是在nums1中的 for(int i = max(0, k - m); i &lt;= min(n, k); i ++ )&#123; // nums2中的元素个数 int j = k - i; // 留i个，删掉n - i个 auto a = maxArray(nums1, n - i); auto b = maxArray(nums2, m - j); // 归并 auto c = merge(a, b); // 选择一个最大的 res = max(res, c); &#125; return res; &#125; // 从nums数组中删掉k个元素，使剩下的元素字典序最大,见lc-402题解 vector&lt;int&gt; maxArray(vector&lt;int&gt; &amp;nums, int k)&#123; vector&lt;int&gt; res; for(auto t : nums)&#123; while(k &amp;&amp; res.size() &amp;&amp; res.back() &lt; t) res.pop_back(), k -- ; res.push_back(t); &#125; while(k &amp;&amp; res.size()) res.pop_back(), k -- ; while(res.size() &amp;&amp; res.front() == 0) res.erase(res.begin()); return res; &#125; vector&lt;int&gt; merge(vector&lt;int&gt; &amp;a, vector&lt;int&gt; &amp;b)&#123; vector&lt;int&gt; res; int n = a.size(), m = b.size(); // 将两个数组中的元素归并到res中 while(res.size() &lt; n + m)&#123; auto t = &amp;a; // 如果b中没有元素了，就将a中元素并入res if(!b.size()) t = &amp;a; // 如果a中没有元素了，就将b中元素并入res if(!a.size()) t = &amp;b; // 如果两个都有元素，那么就并入字典序大的那个 else t = a &gt; b ? &amp;a : &amp; b; // 注意这个比较的复杂度是O(n)的 // 将数并入，指针向后移（删除第一个元素） res.push_back(t-&gt;front()), t-&gt;erase(t-&gt;begin()); &#125; return res; &#125;&#125;; Java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172class Solution &#123; public int[] maxNumber(int[] nums1, int[] nums2, int k) &#123; int[] res = new int[k]; int n = nums1.length, m = nums2.length; // 枚举答案数组中有多少元素是在nums1中的 for(int i = Math.max(0, k - m); i &lt;= Math.min(n, k); i ++ )&#123; // nums2中的元素个数 int j = k - i; // 留i个，删掉n - i个 int[] a = maxArray(nums1, n - i); int[] b = maxArray(nums2, m - j); // 归并 int[] c = merge(a, b); // 找到一个最大的 res = compare(res, c) ? res : c; &#125; return res; &#125; // 将ArrayList&lt;Integer&gt;转化为int[] （不能直接toArray(new int[size])） int[] toArray(ArrayList&lt;Integer&gt; a)&#123; int n = a.size(); int[] res = new int[n]; for(int i = 0; i &lt; n; i ++ ) res[i] = a.get(i); return res; &#125; // 从nums数组中删掉k个元素，使剩下的元素字典序最大,见lc-402题解 int[] maxArray(int[] a, int k)&#123; ArrayList&lt;Integer&gt; res = new ArrayList(); for(int t : a)&#123; while(k &gt; 0 &amp;&amp; res.size() &gt; 0 &amp;&amp; res.get(res.size() - 1) &lt; t)&#123; res.remove(res.size() - 1); k -- ; &#125; res.add(t); &#125; while(k &gt; 0)&#123; res.remove(res.size() - 1); k -- ; &#125; return toArray(res); &#125; // 比较字典序，如果a &gt; b 返回 true boolean compare(int[] a, int[] b, int i, int j)&#123; int n = a.length, m = b.length; while(i &lt; n &amp;&amp; j &lt; m) if(a[i] != b[j]) return a[i] &gt; b[j]; else&#123; i ++ ; j ++ ; &#125; return n - i &gt; m - j; &#125; boolean compare(int[] a, int[] b)&#123; return compare(a, b, 0, 0); &#125; // 将两个数组中的元素归并到res中 int[] merge(int[] a, int[] b)&#123; int n = a.length, m = b.length; ArrayList&lt;Integer&gt; res = new ArrayList(); int i = 0, j = 0; while(i &lt; n &amp;&amp; j &lt; m) // 比较字典序，将字典序大的头一个字符并入答案 if(compare(a, b, i, j)) res.add(a[i ++ ]); else res.add(b[j ++ ]); while(i &lt; n) res.add(a[i ++ ]); while(j &lt; m) res.add(b[j ++ ]); return toArray(res); &#125;&#125;","categories":[],"tags":[]},{"title":"Leetcode34. 在排序数组中查找元素的第一个和最后一个位置","slug":"lc-34","date":"2020-11-30T16:00:00.000Z","updated":"2020-12-01T06:05:21.988Z","comments":true,"path":"lc-34/","link":"","permalink":"http://example.com/lc-34/","excerpt":"题目34. 在排序数组中查找元素的第一个和最后一个位置","text":"题目34. 在排序数组中查找元素的第一个和最后一个位置 算法二分查找给定一个不降序的数组，然后让我们找到某一个数在数组中的起始和结束的位置。如果数组中不含此数的话，返回{-1， -1}。这道题是二分查找的典型应用。 二分查找一般适用于一下情况：给定一个数组，在数组的前半段满足某一性质，而在后半段则满足另一个性质。我们可以用二分查找找到前半段的最右边满足该性质的元素的位置，或者是后半段最左端的满足性质的元素的位置。比如：给定数组 index 1 2 3 4 5 6 element 5 7 7 8 8 10 对于这个数组，在区间[1:5]的元素都是小于等于8的,我们就可以用二分查找,找到5这个位置, 我们把它叫做前半段的右端点；同样的区间[4:6]的元素都是大于等于8的，我们就可以找到4这个位置，我们把它叫做后半段的左端点。 给定下面的二分查找模板和注意的地方，在做题的时候可以直接使用。 1234567891011121314151617// 用于查找后半段的左端点int l = 0, r = n; // 查找的区间范围while(l &lt; r)&#123; int mid = l + r &gt;&gt; 1; // 求中点 if(check(mid)) r = mid; // check用于检查nums[mid]是否满足某一性质 l = mid + 1;&#125;return l; // l就是后半段的左端点// 用于查找前半段的右端点int l = 0, r = n; // 查找的区间范围while(l &lt; r)&#123; int mid = l + r + 1 &gt;&gt; 1; // 求中点 if(check(mid)) l = mid; // check用于检查nums[mid]是否满足某一性质 r = mid - 1;&#125;return l; // l就是前半段的右端点 这道题正好需要使用上面这两个模板，代码如下。 代码C++123456789101112131415161718192021222324252627class Solution &#123;public: vector&lt;int&gt; searchRange(vector&lt;int&gt;&amp; nums, int target) &#123; int n = nums.size(); if(!n) return &#123;-1, -1&#125;; vector&lt;int&gt; res; int l = 0, r = n - 1; // 查找nums数组中最左边满足&gt;=target的元素位置 while(l &lt; r)&#123; int mid = l + r &gt;&gt; 1; if(nums[mid] &gt;= target) r = mid; else l = mid + 1; &#125; if(nums[l] == target) res.push_back(l); // 如果nums[l] != target则nums数组中不含target这个元素 else return &#123;-1, -1&#125;; // 查找nums数组中最右边满足&lt;=target的元素位置 l = 0, r = n - 1; while(l &lt; r)&#123; int mid = l + r + 1 &gt;&gt; 1; if(nums[mid] &lt;= target) l = mid; else r = mid - 1; &#125; res.push_back(l); return res; &#125;&#125;; Java123456789101112131415161718192021222324252627class Solution &#123; public int[] searchRange(int[] nums, int target) &#123; int n = nums.length; int[] res = new int[]&#123;-1, -1&#125;; if(n == 0) return res; int l = 0, r = n - 1; // 查找nums数组中最左边满足&gt;=target的元素位置 while(l &lt; r)&#123; int mid = l + r &gt;&gt; 1; if(nums[mid] &gt;= target) r = mid; else l = mid + 1; &#125; if(nums[l] == target) res[0] = l; // 如果nums[l] != target则nums数组中不含target这个元素 else return res; l = 0; r = n - 1; // 查找nums数组中最右边满足&lt;=target的元素位置 while(l &lt; r)&#123; int mid = l + r + 1 &gt;&gt; 1; if(nums[mid] &lt;= target) l = mid; else r = mid - 1; &#125; res[1] = l; return res; &#125;&#125;","categories":[],"tags":[]},{"title":"Leetcode767.重构字符串","slug":"lc-767","date":"2020-11-29T16:00:00.000Z","updated":"2020-11-29T23:44:44.742Z","comments":true,"path":"lc-767/","link":"","permalink":"http://example.com/lc-767/","excerpt":"题目767. 重构字符串","text":"题目767. 重构字符串 算法虚地址+排序将字符串按照每个字符出现的次数进行排序，然后使用虚地址进行映射。映射方法与之前的Leetcode922. 按奇偶排序数组 II一致，具体请看题解的后半部分。最后判断，如果有两个连续的字符，则说明没有答案，返回空字符串。 如果理解不了的话，可以在排序之后，使用下面代码对字符串进行遍历，就会发现，在虚拟地址空间中，字符串确实是按照出现次数排序的。 C++12for(int i = 0; i &lt; n; i ++ ) cout &lt;&lt; N(i);cout &lt;&lt; endl; Java12for(int i = 0; i &lt; n; i ++ ) System.out.print(mp(i));System.out.println(); 代码C++123456789101112131415161718192021222324252627282930313233343536373839class Solution &#123;public: vector&lt;int&gt; cnt = vector&lt;int&gt;(26); string S; int n; // 虚地址映射 #define N(i) S[(1 + 2*(i)) % (n | 1)] // 快速排序 void sort(int l, int r)&#123; if(l &gt;= r) return; int i = l - 1, j = r + 1; char x = N((l + r) / 2); while(i &lt; j)&#123; // 按照字符的出现次数作为第一关键字，字符大小作为第二关键字 do i ++ ; while(cnt[N(i) - &#x27;a&#x27;] &lt; cnt[x - &#x27;a&#x27;] || (N(i) &lt; x &amp;&amp; cnt[N(i) - &#x27;a&#x27;] == cnt[x - &#x27;a&#x27;])); do j -- ; while(cnt[N(j) - &#x27;a&#x27;] &gt; cnt[x - &#x27;a&#x27;] || (N(j) &gt; x &amp;&amp; cnt[N(j) - &#x27;a&#x27;] == cnt[x - &#x27;a&#x27;])); if(i &lt; j) swap(N(i), N(j)); &#125; // 递归到下一层 sort(l, j), sort(j + 1, r); &#125; string reorganizeString(string _S) &#123; S = _S; n = S.size(); // 对字符出现的次数进行计数 for(auto t : S) cnt[t - &#x27;a&#x27;] ++ ; sort(0, S.size() - 1); // 如果要查看虚地址空间中的顺序，去除下面的注释 // for(int i = 0; i &lt; n; i ++ ) cout &lt;&lt; N(i); // cout &lt;&lt; endl; // 如果有两个连续的字符，返回空串 for(int i = 1; i &lt; n; i ++ ) if(S[i] == S[i - 1]) return &quot;&quot;; return S; &#125;&#125;; Java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657class Solution &#123; StringBuilder S; int n; // 用于记录S中字符出现的次数 int[] cnt = new int[26]; // 用于地址映射 int get(int i)&#123; return (2 * i + 1) % (n | 1); &#125; // 返回虚地址空间中的S[i] char mp(int i)&#123; int x = get(i); return S.charAt(x); &#125; // 在虚地址空间中进行交换 void swap(int i, int j)&#123; int x = get(i), y = get(j); char t = S.charAt(x); S.setCharAt(x, S.charAt(y)); S.setCharAt(y, t); &#125; // 快速排序 void sort(int l, int r)&#123; if(l &gt;= r) return; char c = mp((l + r) / 2); int i = l - 1, j = r + 1, x = cnt[c - &#x27;a&#x27;]; while(i &lt; j)&#123; // 第一关键字：字符出现的次数； 第二关键字： 字符大小 do i ++ ; while(cnt[mp(i) - &#x27;a&#x27;] &lt; x || (mp(i) &lt; c &amp;&amp; cnt[mp(i) - &#x27;a&#x27;] == x)); do j -- ; while(cnt[mp(j) - &#x27;a&#x27;] &gt; x || (mp(j) &gt; c &amp;&amp; cnt[mp(j) - &#x27;a&#x27;] == x)); if(i &lt; j) swap(i, j); &#125; sort(l, j); sort(j + 1, r); &#125; public String reorganizeString(String _S) &#123; S = new StringBuilder(_S); n = S.length(); // 统计字符出现的次数 for(int i = 0; i &lt; n; i ++ ) cnt[(char)S.charAt(i) - &#x27;a&#x27;] ++ ; // 排序 sort(0, n - 1); // 如果要查看虚地址空间中字符排列，请打开下列注释 // for(int i = 0; i &lt; n; i ++ ) System.out.print(mp(i)); // System.out.println(); // 判断是否有连续字符 for(int i = 1; i &lt; n; i ++ ) if(S.charAt(i) == S.charAt(i - 1)) // 如果有，返回空串 return new String(); return S.toString(); &#125;&#125;","categories":[],"tags":[]},{"title":"Leetcode976. 三角形的最大周长","slug":"lc-976","date":"2020-11-28T16:00:00.000Z","updated":"2020-11-28T23:14:16.822Z","comments":true,"path":"lc-976/","link":"","permalink":"http://example.com/lc-976/","excerpt":"题目976. 三角形的最大周长","text":"题目976. 三角形的最大周长 算法贪心我首先想到的是两边之和大于第三边，暴力枚举了一下，TLE。 12345678910111213141516171819class Solution &#123;public: bool check(int a, int b, int c)&#123; if(a + b &lt;= c) return false; if(a + c &lt;= b) return false; if(b + c &lt;= a) return false; return true; &#125; int largestPerimeter(vector&lt;int&gt;&amp; A) &#123; int n = A.size(), res = 0; for(int i = 0; i &lt; n; i ++ ) for(int j = i + 1; j &lt; n; j ++ ) for(int k = j + 1; k &lt; n; k ++ )&#123; if(check(A[i], A[j], A[k])) res = max(res, A[i] + A[j] + A[k]); &#125; return res; &#125;&#125;; 然后又看了其他人的题解，用的是贪心算法：从大到小枚举最长边c，找到和它相邻并且比它小的两个数a和b，检查他们是否能组成三角形。 对于一个边长为a，b，c的一个三角形，且a &lt;= b &lt;= c，那么如果满足a + b &gt;= c，也就必然满足a + c &gt;= b &amp;&amp; b + c &gt;= a ；反之，如果不满足a + b &gt;= c，因为a，b已经是最大的小于c的两个数了，所以其他数也必不可能满足，c不可能是结果集中的边。继续遍历下一个数。 而我们是从大到小枚举最长边的，所以第一个符合条件的数也必然是周长最长的。 代码C++123456789101112class Solution &#123;public: int largestPerimeter(vector&lt;int&gt;&amp; A) &#123; // 排序 sort(A.begin(), A.end()); // 从大到小枚举最长边 for(int i = A.size() - 1; i &gt;= 2; i -- ) if(A[i - 2] + A[i - 1] &gt; A[i]) return A[i] + A[i - 1] + A[i - 2]; return 0; &#125;&#125;; Java1234567891011class Solution &#123; public int largestPerimeter(int[] A) &#123; // 排序 Arrays.sort(A); // 从大到小枚举最长边 for(int i = A.length - 1; i &gt;= 2; i -- ) if(A[i - 2] + A[i - 1] &gt; A[i]) return A[i] + A[i - 1] + A[i -2]; return 0; &#125;&#125;","categories":[],"tags":[]},{"title":"Leetcode493.翻转对","slug":"lc-493","date":"2020-11-27T16:00:00.000Z","updated":"2020-11-28T11:30:40.418Z","comments":true,"path":"lc-493/","link":"","permalink":"http://example.com/lc-493/","excerpt":"题目493. 翻转对","text":"题目493. 翻转对 算法离散化+树状数组这道题的算法和之前的Leetcode327.区间和的个数相同，这里就简单说一下这两个算法的作用 离散化离散化就是将n个范围比较广的数，映射到1~n当中（也可以从0开始，不过树状数组需要从1开始）,大致的步骤就是将n个数排序，去重，然后我们就得到了一个元素各不相同的有序数组，我们就可以用二分查找找到某个数的下标，这样我们就完成了离散化。 树状数组一言以蔽之，树状数组就是一个数组，元素i维护的是某一个数组(i - lowerbit(i), i]（左闭右开）的区间信息，这个信息可以是区间和，最大值，最小值这种具有区间可加性的性质。 区间可加性是我自己编的，hhh，就是说给定两个区间的信息，我们可以用这些信息求出这两个区间并集的信息，比如给定两个数组的两个不相交的区间和，我们只要将两个数相加，就可以求出这两个区间并集的区间和。同样，给定两个区间的最大值，这两个最大值的最大值就是这两个区间并集的最大值，诸如此类。 这里只是我的个人理解，网上的文章很多，大家可以自行查阅。 在本题里面，我们就是将数组nums中的元素先进行离散化（注意实际离散化的是2t和t - 1，t为nums中的元素），然后再从后先前遍历nums，查询之前插入的数有多少是小于nums[i]的，然后将2*nums[i]插入进去。 代码C++123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354class Solution &#123;public: // 防止溢出int typedef long long LL; // 离散化数组 vector&lt;LL&gt; vals; // 二分查找，用于查找x在vals数组的位置，从1开始。 int get(LL x)&#123; int l = 0, r = vals.size() - 1; while(l &lt; r)&#123; int mid = l + r &gt;&gt; 1; if(vals[mid] &gt;= x) r = mid; else l = mid + 1; &#125; return l + 1; &#125; // 树状数组 vector&lt;int&gt; tr; // lowerbit,求x的二进制数最低一位的1 int lowerbit(int x)&#123; return x &amp; -x; &#125; // 将数组x的位置上加v void add(int x, int v)&#123; //维护的是区间信息 for(int i = x; i &lt; tr.size(); i += lowerbit(i)) tr[i] += v; &#125; // 对数组[1, x]的区间进行求和 int query(int x)&#123; int res = 0; for(int i = x; i; i -= lowerbit(i)) res += tr[i]; return res; &#125; int reversePairs(vector&lt;int&gt;&amp; nums) &#123; // 将t∈nums，离散化2t(用于插入到树状数组)和t - 1（用于查询） for(auto t : nums) vals.push_back(2LL * t), vals.push_back(t - 1); // 排序 sort(vals.begin(), vals.end()); // 去重 vals.erase(unique (vals.begin(), vals.end()), vals.end()); // 初始化树状数组 tr.resize(vals.size() + 1); int res = 0; // 从后向前遍历 for(int i = nums.size() - 1; i &gt;= 0; i -- )&#123; // 查询之前遍历的数的二倍有多少是小于nums[i]的 res += query(get(nums[i] - 1)); // 将此数的二倍插入进去 add(get(2LL * nums[i]), 1); &#125; return res; &#125;&#125;; Java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051class Solution &#123; // 离散化数组 ArrayList&lt;Long&gt; vals = new ArrayList&lt;&gt;(); int get(Long x)&#123; int l = 0, r = vals.size() - 1; while(l &lt; r)&#123; int mid = (l + r) / 2; if(vals.get(mid) &gt;= x) r = mid; else l = mid + 1; &#125; return l + 1; &#125; // 树状数组 ArrayList&lt;Integer&gt; tr = new ArrayList&lt;&gt;();; // lowerbit,求x的二进制数最低一位的1 int lowerbit(int x)&#123; return x &amp; -x; &#125; // 将数组x的位置上加v void add(int x, int v)&#123; for(int i = x; i &lt; tr.size(); i += lowerbit(i)) tr.set(i, tr.get(i) + v); &#125; // 对数组[1, x]的区间进行求和 int query(int x)&#123; int res = 0; for(int i = x; i &gt; 0; i -= lowerbit(i)) res += tr.get(i); return res; &#125; public int reversePairs(int[] nums) &#123; // 将t∈nums，离散化2t(用于插入到树状数组)和t - 1（用于查询） for(int t : nums)&#123; vals.add(2L * t); vals.add(t - 1L); &#125; // 去重，排序 vals = new ArrayList&lt;&gt;(new HashSet&lt;&gt;(vals)); Collections.sort(vals); int res = 0; // 初始化树状数组 for(int i = 0; i &lt; vals.size() + 1; i ++ ) tr.add(0); // 从后向前遍历 for(int i = nums.length - 1; i &gt;= 0; i -- )&#123; // 查询之前遍历的数的二倍有多少是小于nums[i]的 res += query(get(nums[i] - 1L)); // 将此数的二倍插入进去 add(get(2L * nums[i]), 1); &#125; return res; &#125;&#125;","categories":[],"tags":[]},{"title":"Leetcode454. 四数相加 II","slug":"lc-454","date":"2020-11-26T16:00:00.000Z","updated":"2020-11-28T23:13:20.736Z","comments":true,"path":"lc-454/","link":"","permalink":"http://example.com/lc-454/","excerpt":"题目454. 四数相加 II","text":"题目454. 四数相加 II 算法哈希表遍历数组A和B，将两数组元素相加之和存入哈希表并且计数；然后遍历C和D，在哈希表中查找两数组元素相加的相反数的个数，加入到答案中即可。 代码C++1234567891011121314151617class Solution &#123;public: int fourSumCount(vector&lt;int&gt;&amp; A, vector&lt;int&gt;&amp; B, vector&lt;int&gt;&amp; C, vector&lt;int&gt;&amp; D) &#123; unordered_map&lt;int, int&gt; mp; // 遍历A，B for(auto t : A) for(auto k : B) mp[t + k] ++ ; int res = 0; // 遍历C，D for(auto t : C) for(auto k : D) // 找到哈希表中C，D中元素之和的相反数的个数 res += mp[-t - k]; return res; &#125;&#125;; Java12345678910111213141516class Solution &#123; public int fourSumCount(int[] A, int[] B, int[] C, int[] D) &#123; Map&lt;Integer, Integer&gt; mp = new HashMap&lt;&gt;(); // 遍历A，B for(int t : A) for(int k : B) mp.put(t + k, mp.getOrDefault(t + k, 0) + 1); int res = 0; // 遍历C，D for(int t : C) for(int k : D) // 找到哈希表中C，D中元素之和的相反数的个数 res += mp.getOrDefault(-t - k, 0); return res; &#125;&#125;","categories":[],"tags":[]},{"title":"Leetcode164.最大间距","slug":"lc-164","date":"2020-11-25T16:00:00.000Z","updated":"2020-11-26T07:53:39.745Z","comments":true,"path":"lc-164/","link":"","permalink":"http://example.com/lc-164/","excerpt":"题目164. 最大间距","text":"题目164. 最大间距 算法题目要求使用O(n)的算法解决，思路还是比较复杂的，请耐心看完，我会逐步推导思路，相信你一定会有收获！ 排序 O(nlogn)大家第一时间想到的肯定是这个算法，非常直观，但是不符合题目对时间复杂度的，不过也能AC，思路就不解释了。 代码C++123456789101112class Solution &#123;public: int maximumGap(vector&lt;int&gt;&amp; nums) &#123; int res = 0; // 排序 sort(nums.begin(), nums.end()); // 找到答案 for(int i = 1; i &lt; nums.size(); i ++ ) res = max(res, abs(nums[i] - nums[i - 1])); return res; &#125;&#125;; Java1234567891011class Solution &#123; public int maximumGap(int[] nums) &#123; // 排序 Arrays.sort(nums); int res = 0; // 找到答案 for(int i = 1; i &lt; nums.length; i ++ ) res = Math.max(res, nums[i] - nums[i - 1]); return res; &#125;&#125; 桶排序 O(n)大致思路假如说，我们有n个桶，我们将n个数，放入到对应的桶中，在桶中的元素需要满足这样的性质：如果说在任意一个桶中任取两个元素x,y，那么我们想要找到的最大间距不可能是abs(x - y)。 所以说，我们要的最大间距一定是在两个桶之间的，这样我们就只需要遍历这n个桶，我们想要的最大间距就在每两个相邻的桶的最小元素和最大元素之差中。 举个例子，对于数组nums = [3, 6, 9, 1], 我们需要四个桶，分别存放数值在(-INF, 1], (1, 4], (4, 7], (7, 10]的元素，然后我们将元素放到这些桶里面,结果是： 桶1:(-INF, 1] 桶2:(1, 4] 桶3:(4, 7] 桶4:(7, 10] 1 3 6 9 然后我们遍历这些桶，将i号桶的最小值和i - 1号桶的最大值做差，找到一个最大值，就是我们想要的答案了。 更进一步我们怎么保证同一个桶中的两个元素做差不会是答案呢？我们可以适当的调整桶的区间长度,就可以得到想要的答案了，最极端的，我们每个桶的长度都是1，那么我们的每个桶中就只有一个元素，那答案自然就是在两个相邻的桶中了。 注意：这里相邻的桶，不只是指那些编号相邻的点，如果说第i号桶中没有元素，就视作第i个桶不存在，i - 1号桶与 i + 1号桶相邻。 那么，我们应该怎样调整桶的区间长度呢？ 设:在nums数组中：有n个元素, 元素的最小值是m, 最大值是M。 n个数会有n - 1个间隔，如果这n- 1个间隔，如果说n 个数均匀分布的话，那么他们的间隔就是（M - m） / (n - 1)。给出一个结论，在这道题目中，我们想要的最大间距 &gt;= (M - m) / (n - 1), 当且仅当n个数均匀分布的时候等号成立，因为如果我们试图将两个数靠近，它就会与另一个数的距离更远，最大间距会增加。 所以，我们利用这个性质，就把桶的间距设置成(M - m) / (n - 1)就可以了。如果取下取整也是可以的，只不过这个桶的数量可能要超过n。 代码C++12345678910111213141516171819202122232425262728293031323334353637383940class Solution &#123;public: struct bucket&#123; // 注意这里，因为要做差，所以声明成long long类型，防止int溢出 long long l, r; bucket()&#123; l = INT_MAX, r = INT_MIN; &#125; &#125;; int maximumGap(vector&lt;int&gt;&amp; nums) &#123; int m = INT_MAX, M = INT_MIN; // 取最大最小值 for(auto t : nums) m = min(m, t), M = max(M, t); // 取桶的区间距离 int n = nums.size(); if(n &lt; 2) return 0; // a / b 上取整 = (a + b - 1) / b 下取整 // 桶的最小间距是1 int x = max(1,(M - m + n - 2) / (n - 1)); // 将每个数放到桶中，每个桶只保存桶中最大的数和最小的数 vector&lt;bucket&gt; buckets(n); for(auto t : nums)&#123; int idx = (t - m + x - 1) / x; buckets[idx].l = min((int)buckets[idx].l, t); buckets[idx].r = max((int)buckets[idx].r, t); &#125; // 遍历每个桶，得出答案 int res = 0, last = -2e9; for(auto &amp;bucket : buckets)&#123; // 如果bucket.l = INT_MAX或者bucket.r = INT_MIN // 则表示该桶中没有元素，跳过该桶。 if(bucket.l == INT_MAX) continue; // 当前桶的最小值和左边相邻的桶的最大值做差,找到一个最大的作为答案 if(last != -2e9) res = max(res, (int)bucket.l - last); // 记录当前桶的最大值 last = bucket.r; &#125; return res; &#125;&#125;; Java123456789101112131415161718192021222324252627282930313233343536373839class Solution &#123; // 桶 class bucket&#123; long l = (long)2e9, r = (long)-2e9; &#125; public int maximumGap(int[] nums) &#123; // 找到数组中元素的最大值和最小值 int m = (int)2e9, M = (int)-2e9; for(int t : nums)&#123; m = Math.min(m, t); M = Math.max(M, t); &#125; int n = nums.length; if(n &lt; 2) return 0; // 计算桶的区间距离 int x = Math.max(1, (M - m + n - 2) / (n - 1)); // 初始化桶 bucket[] buckets = new bucket[n]; for(int i = 0; i &lt; n; i ++ ) buckets[i] = new bucket(); // 将每个数放到桶中，每个桶只保存桶中最大的数和最小的数 for(int t : nums)&#123; int idx = (t - m + x - 1) / x; buckets[idx].l = Math.min(buckets[idx].l, t); buckets[idx].r = Math.max(buckets[idx].r, t); &#125; // 遍历桶，找到答案 int res = 0, last = (int)-2e9; for(bucket buc : buckets)&#123; // 如果bucket.l = 2e9或者bucket.r = -2e9 // 则表示该桶中没有元素，跳过该桶。 if(buc.l == 2e9) continue; // 当前桶的最小值和左边相邻的桶的最大值做差,找到一个最大的作为答案 if(last != -2e9) res = Math.max(res, (int)buc.l - last); // 记录当前桶的最大值 last = (int)buc.r; &#125; return res; &#125;&#125;","categories":[],"tags":[]},{"title":"Leetcode1370. 上升下降字符串","slug":"lc-1370","date":"2020-11-24T16:00:00.000Z","updated":"2020-11-25T00:39:28.257Z","comments":true,"path":"lc-1370/","link":"","permalink":"http://example.com/lc-1370/","excerpt":"题目1370. 上升下降字符串","text":"题目1370. 上升下降字符串 算法模拟 O(n)题目的意思是将字符串重新排列，排列的顺序是先单调上升，然后再单调下降，然后再单调上升，如此往复，形成一个上升下降字符串。 注意在极值点处是可以有两个相同的字母的，如”abccbaabccba”中的“cc”和“aa”。 代码C++1234567891011121314151617181920class Solution &#123;public: string sortString(string s) &#123; // 对单词的字母进行计数 vector&lt;int&gt; cnt(26); // 对单词中的字母进行计数，将a~z映射到0~25 for(auto c : s) cnt[c - &#x27;a&#x27;] ++ ; string res; // 将所有字母重新排列 while(res.size() &lt; s.size())&#123; // 从a开始遍历，形成一个单调上升的字符串。 for(int i = 0; i &lt; 26; i ++ ) if(cnt[i]) res += i + &#x27;a&#x27;, cnt[i] -- ; // 从z开始遍历，形成一个单调下降的字符串。 for(int i = 25; ~i; i -- ) if(cnt[i]) res += i + &#x27;a&#x27;, cnt[i] -- ; &#125; return res; &#125;&#125;; Java12345678910111213141516171819202122232425262728class Solution &#123; public String sortString(String s) &#123; // 括号里面的26只是预留26个空位 ArrayList&lt;Integer&gt; cnt = new ArrayList&lt;Integer&gt;(26); // 初始化 for(int i = 0; i &lt; 26; i ++ ) cnt.add(0); // 对单词中的字母进行计数，将a~z映射到0~25 for(int i = 0; i &lt; s.length(); i ++ ) cnt.set(s.charAt(i) - &#x27;a&#x27;, cnt.get(s.charAt(i) - &#x27;a&#x27;) + 1); StringBuilder res = new StringBuilder(); // 将所有字母重新排列 while(res.length() &lt; s.length())&#123; // 从a开始遍历，形成一个单调上升的字符串。 for(int i = 0; i &lt; 26; i ++ ) if(cnt.get(i) != 0)&#123; res.append((char)(&#x27;a&#x27; + i)); cnt.set(i, cnt.get(i) - 1); &#125; // 从z开始遍历，形成一个单调下降的字符串。 for(int i = 25; i &gt;= 0; i -- ) if(cnt.get(i) != 0)&#123; res.append((char)(&#x27;a&#x27; + i)); cnt.set(i, cnt.get(i) - 1); &#125; &#125; return res.toString(); &#125;&#125;","categories":[],"tags":[]},{"title":"Leetcode222. 完全二叉树的节点个数","slug":"lc-222","date":"2020-11-23T16:00:00.000Z","updated":"2020-11-25T22:33:12.793Z","comments":true,"path":"lc-222/","link":"","permalink":"http://example.com/lc-222/","excerpt":"","text":"题目222. 完全二叉树的节点个数 算法DFS O(n)这就是考研中很常见的前序遍历。我们平时使用的递归绝大部分都可以归类为DFS，所谓DFS就是”深度优先搜索”，也有些人叫它“暴搜”我们通常用DFS去暴力搜索所有解空间，然后将我们想要的答案加入到答案数组中。 代码C++123456789101112class Solution &#123;public: int countNodes(TreeNode* root) &#123; if(!root) return 0; // 当前子树根节点一个 int res = 1; // 左右子树 res += countNodes(root-&gt;left); res += countNodes(root-&gt;right); return res; &#125;&#125;; Java123456class Solution &#123; public int countNodes(TreeNode root) &#123; if(root == null) return 0; return countNodes(root.left) + countNodes(root.right) + 1; &#125;&#125; DFS优化 O(logn)本题给的树是一颗完全二叉树，所以这棵树或者这棵树的子树，一定会有满二叉树，我们可以根据树的高度来计算满二叉树中的节点数量。这样，在dfs到某棵子树的时候，我们先判断这颗子树是不是满二叉树，如果是，我们就直接计算高度，然后根据高度计算子树的节点数，然后返回子树中节点的数量，树的高度就是时间复杂度。 代码C++1234567891011121314class Solution &#123;public: int countNodes(TreeNode* root) &#123; if(!root) return 0; int l = 0, r = 0; // 分别从根节点沿着左儿子， 右儿子走 for(auto p = root; p; p = p-&gt;left) l ++; for(auto p = root; p; p = p-&gt;right) r ++ ; // 因为是完全二叉树，如果左边遍历到的节点数量和右边相等，则该子树是满二叉树 // 满二叉树的节点数量 n = 2^h - 1， h为树的高度 if(l == r) return pow(2, l) - 1; return countNodes(root-&gt;left) + countNodes(root-&gt;right) + 1; &#125;&#125;; Java12345678910111213class Solution &#123; public int countNodes(TreeNode root) &#123; if(root == null) return 0; int l = 0, r = 0; // 分别从根节点沿着左儿子， 右儿子走 for(TreeNode p = root; p != null; p = p.left) l ++ ; for(TreeNode p = root; p != null; p = p.right) r ++ ; // 因为是完全二叉树，如果左边遍历到的节点数量和右边相等，则该子树是满二叉树 // 满二叉树的节点数量 n = 2^h - 1， h为树的高度 if(l == r) return (int)Math.pow(2, l) - 1; return countNodes(root.left) + countNodes(root.right) + 1; &#125;&#125;","categories":[],"tags":[]},{"title":"Leetcode452. 用最少数量的箭引爆气球","slug":"lc-452","date":"2020-11-22T16:00:00.000Z","updated":"2020-11-23T15:25:02.459Z","comments":true,"path":"lc-452/","link":"","permalink":"http://example.com/lc-452/","excerpt":"题目452. 用最少数量的箭引爆气球","text":"题目452. 用最少数量的箭引爆气球 算法贪心思路给定一些区间，我们选定尽量少的点，让这些区间上至少都有一个点。首先我们先把区间按照右端点进行排序。 对于每个区间，我们选择它的右端点射箭，如果射箭的点不在区间上，则说明我们要先把当前组的气球先射爆，再另外射一箭。 代码C++1234567891011121314151617181920212223class Solution &#123;public: int findMinArrowShots(vector&lt;vector&lt;int&gt;&gt;&amp; points) &#123; int n = points.size(); // 按照区间右端点排序 sort(points.begin(), points.end(), [](const vector&lt;int&gt; &amp;a, const vector&lt;int&gt; &amp;b)-&gt;bool&#123; if(a[0] != b[0]) return a[0] &lt; b[0]; return a[1] &lt; b[1]; &#125;); int res = 0; // 第一箭设置在无穷远处 long long shot = -2e10; // 遍历所有区间 for(int i = 0; i &lt; n; i ++ )&#123; // 如果当前射箭的点不在区间上，更新射箭的点。 if(!(points[i][0] &lt;= shot &amp;&amp; shot &lt;= points[i][1]))&#123; res ++ ; shot = points[i][1]; &#125; &#125; return res; &#125;&#125;; Java12345678910111213141516171819202122class Solution &#123; public int findMinArrowShots(int[][] points) &#123; int n = points.length; // 按照区间右端点排序 Arrays.sort(points, new Comparator&lt;int[]&gt;()&#123; public int compare(int[] a, int[] b)&#123; return a[1] - b[1]; &#125; &#125;); // 第一箭设置在无穷远处 long shot = (long)-2e10; int res = 0; // 遍历所有区间 for(int i = 0; i &lt; n; i ++ ) // 如果当前射箭的点不在区间上，更新射箭的点。 if(!(points[i][0] &lt;= shot &amp;&amp; shot &lt;= points[i][1]))&#123; shot = points[i][1]; res ++ ; &#125; return res; &#125;&#125;","categories":[],"tags":[]},{"title":"Leetcode242. 有效的字母异位词","slug":"lc-242","date":"2020-11-21T16:00:00.000Z","updated":"2020-11-21T22:59:28.028Z","comments":true,"path":"lc-242/","link":"","permalink":"http://example.com/lc-242/","excerpt":"题目242. 有效的字母异位词","text":"题目242. 有效的字母异位词 算法思路如果两个单词中字母出现的次数一致的话，那么它们就是字母异位词，否则则不是。 代码C++123456789101112131415class Solution &#123;public: bool isAnagram(string s, string t) &#123; // 如果两个单词长度不相等，必不是 if(s.size() != t.size()) return false; unordered_map&lt;char, int&gt; st; // 统计s中字母出现的次数 for(auto c : s) st[c] ++ ; // 比对两者字母出现的次数是否相等 for(auto c : t) if(!st[c]) return false; else st[c] -- ; return true; &#125;&#125;; Java12345678910111213141516171819class Solution &#123; public boolean isAnagram(String s, String t) &#123; // 如果两个单词长度不相等，必不是 if(s.length() != t.length()) return false; Map&lt;Character, Integer&gt; mp = new HashMap&lt;&gt;(); // 统计s中字母出现的次数 for(char c : s.toCharArray()) if(!mp.containsKey(c)) mp.put(c, 1); else mp.put(c, mp.get(c) + 1); // 比对两者字母出现的次数是否相等 for(char c : t.toCharArray()) if(!mp.containsKey(c)) return false; else&#123; mp.put(c, mp.get(c) - 1); if(mp.get(c) == 0) mp.remove(c); &#125; return true; &#125;&#125;","categories":[],"tags":[]},{"title":"Leetcode148. 排序链表","slug":"lc-148","date":"2020-11-20T16:00:00.000Z","updated":"2020-11-21T12:31:38.613Z","comments":true,"path":"lc-148/","link":"","permalink":"http://example.com/lc-148/","excerpt":"题目148. 排序链表","text":"题目148. 排序链表 算法链表的排序本道题要求在时间复杂度O(nlogn), 空间复杂度O(1)下，对链表进行排序。如果没有这个要求，我们可以用昨天的算法对链表进行排序，时间复杂度O(n^2)，空间复杂度O(1),时间复杂度不符合要求。 归并排序对于归并排序，特别的链表的归并排序，大家可能都和我一样都觉得这个算法很麻烦，但是这是很常见的面试题，所以请大家耐心看完，相信你一定会有收获的！对于归并排序的实现，我们有两种算法，一种是自顶向下的，另一种是自底向上的。 自顶向下的归并排序所谓自顶向下的排序算法，就是把数组元素不断的二分，直到子数组的元素个数为一个，因为这个时候子数组必定是已有序的，然后将两个有序的序列合并成一个新的有序的序列，两个新的有序序列又可以合并成另一个新的有序序列，以此类推，直到合并成一个有序的数组。 自底向上的归并排序而自底向上的归并排序算法的思想就是数组中先一个一个归并成两两有序的序列，两两有序的序列归并成四个四个有序的序列，然后四个四个有序的序列归并八个八个有序的序列，以此类推，直到，归并的长度大于整个数组的长度，此时整个数组有序。 两者之间的区别无非就是用递归实现，和用迭代实现。因为本题要求空间复杂度是常数级时间复杂度O(1)，所以我们不能使用递归，因为递归会使用系统栈，空间复杂度O(logn);所以我们选择用迭代实现自底向上的归并排序。 思路其实想要实现链表的自底向上的归并排序只需要简单的几步： 统计链表的长度 从1开始枚举长度 2.1 按照长度对链表两两进行拆分 2.2 将拆分出来的两个子链表进行归并排序并插入到原链表后面。 代码C++1234567891011121314151617181920212223242526272829303132333435363738394041/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) &#123;&#125; * ListNode(int x) : val(x), next(nullptr) &#123;&#125; * ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode* sortList(ListNode* head) &#123; int n = 0; for(auto p = head; p; p = p-&gt;next) n ++ ; auto dummy = new ListNode(-1, head); // 枚举子链表的长度 for(int len = 1; len &lt; n; len *= 2)&#123; // cur从第一个节点开始遍历,rear将节点按顺序插入到dummy后。 auto cur = dummy-&gt;next, rear = dummy; while(cur)&#123; // l和r分别指向两个需要归并的两个链表 auto l = new ListNode(-1), r = new ListNode(-1); auto r1 = l, r2 = r; // 将两个链表从原链表取下来 for(int i = 0; i &lt; len &amp;&amp; cur; i ++ ) r1 = r1-&gt;next = cur, cur = cur-&gt;next; r1-&gt;next = NULL; for(int i = 0; i &lt; len &amp;&amp; cur; i ++ ) r2 = r2-&gt;next = cur, cur = cur-&gt;next; r2-&gt;next = NULL; // 按顺序插入到原链表后 auto p = l-&gt;next, q = r-&gt;next; while(p &amp;&amp; q) if(p-&gt;val &lt;= q-&gt;val) rear = rear-&gt;next = p, p = p-&gt;next; else rear = rear-&gt;next = q, q = q-&gt;next; while(p) rear = rear-&gt;next = p, p = p-&gt;next; while(q) rear = rear-&gt;next = q, q = q-&gt;next; &#125; &#125; return dummy-&gt;next; &#125;&#125;; Java1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode() &#123;&#125; * ListNode(int val) &#123; this.val = val; &#125; * ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125; * &#125; */class Solution &#123; public ListNode sortList(ListNode head) &#123; int n = 0; for(ListNode p = head; p != null; p = p.next) n ++ ; ListNode dummy = new ListNode(-1, head); // 枚举子链表的长度 for(int len = 1; len &lt; n; len *= 2)&#123; // cur从第一个节点开始遍历,rear将节点按顺序插入到dummy后 ListNode cur = dummy.next, rear = dummy; while(cur != null)&#123; // l和r分别指向两个需要归并的两个链表 ListNode l = new ListNode(-1), r1 = l; ListNode r = new ListNode(-1), r2 = r; // 将两个链表从原链表取下来 for(int i = 0; i &lt; len &amp;&amp; cur != null; i ++ )&#123; r1 = r1.next = cur; cur = cur.next; &#125; r1.next = null; for(int i = 0; i &lt; len &amp;&amp; cur != null; i ++ )&#123; r2 = r2.next = cur; cur = cur.next; &#125; r2.next = null; // 按顺序插入到原链表后 ListNode p = l.next, q = r.next; while(p != null &amp;&amp; q != null)&#123; if(p.val &lt;= q.val)&#123; rear = rear.next = p; p = p.next; &#125; else&#123; rear = rear.next = q; q = q.next; &#125; &#125; while(p != null)&#123; rear = rear.next = p; p = p.next; &#125; while(q != null)&#123; rear = rear.next = q; q = q.next; &#125; &#125; &#125; return dummy.next; &#125;&#125;","categories":[],"tags":[]},{"title":"Leetcode283. 移动零","slug":"lc-283","date":"2020-11-20T00:14:45.144Z","updated":"2020-11-20T00:14:45.144Z","comments":true,"path":"lc-283/","link":"","permalink":"http://example.com/lc-283/","excerpt":"题目283. 移动零 双指针 O(n)使用两个指针i和j来解决这道题，我们用指针i来遍历数组nums,定义nums[0 : j - 1]都是非零元素，这样，指针j指向的就是一个值为0的元素，所以在我们遍历的时候，只要碰到非零元素，直接交换即可。","text":"题目283. 移动零 双指针 O(n)使用两个指针i和j来解决这道题，我们用指针i来遍历数组nums,定义nums[0 : j - 1]都是非零元素，这样，指针j指向的就是一个值为0的元素，所以在我们遍历的时候，只要碰到非零元素，直接交换即可。 代码C++1234567class Solution &#123;public: void moveZeroes(vector&lt;int&gt;&amp; nums) &#123; for(int i = 0, j = 0; i &lt; nums.size(); i ++ ) if(nums[i] != 0) swap(nums[i], nums[j ++ ]); &#125;&#125;; Java1234567891011121314class Solution &#123; int[] nums; void swap(int i, int j)&#123; int t = nums[i]; nums[i] = nums[j]; nums[j] = t; &#125; public void moveZeroes(int[] _nums) &#123; nums = _nums; for(int i = 0, j = 0; i &lt; nums.length; i ++ )&#123; if(nums[i] != 0) swap(i, j ++ ); &#125; &#125;&#125;","categories":[],"tags":[]},{"title":"Leetcode147. 对链表进行插入排序","slug":"lc-147","date":"2020-11-19T16:00:00.000Z","updated":"2020-11-20T00:14:34.180Z","comments":true,"path":"lc-147/","link":"","permalink":"http://example.com/lc-147/","excerpt":"题目147. 对链表进行插入排序","text":"题目147. 对链表进行插入排序 思路这道题是一道插入排序，插入排序的思想很简单，遍历每个元素，在前面第一个大于等于此元素的元素前把此元素插入进去。 不过这道题比较特殊的地方在于我们操作的链表，而不是数组，其实链表更加适合插入，因为数组的插入需要把后面的元素都向后挪动一位，时间复杂度O(n)；而对于链表，插入一个节点的时间复杂度只有O(1)。但是对于单链表的插入，我们要记住一个原则，那就是只能在一个节点的后面插入新节点。 所以，我们只要遍历链表，然后在之前已经排过序的链表中找到第一个大于等于当前遍历的节点的前序节点即可。 代码Java1234567891011121314151617181920212223class Solution &#123; public ListNode insertionSortList(ListNode head) &#123; // 指向排过序的链表 ListNode dummy = new ListNode(-1); // 遍历链表 for(ListNode p = head; p != null;)&#123; ListNode q = p.next; // v是u的前序节点 ListNode v = dummy, u = v.next; // 循环后u指向第一个大于等于p的节点 while(u != null &amp;&amp; u.val &lt; p.val)&#123; v = u; u = u.next; &#125; // 将p插入到u的前序节点v后面 p.next = v.next; v.next = p; // p向后挪动一位 p = q; &#125; return dummy.next; &#125;&#125; C++1234567891011121314151617181920class Solution &#123;public: ListNode* insertionSortList(ListNode* head) &#123; // 指向排过序的链表 auto dummy = new ListNode(-1); // 遍历链表 for(auto p = head; p;)&#123; auto q = p-&gt;next; // v是u的前序节点 auto v = dummy, u = v-&gt;next; // 循环后u指向第一个大于等于p的节点 while(u &amp;&amp; u-&gt;val &lt; p-&gt;val) v = u, u = u-&gt;next; // 将p插入到u的前序节点v后面 p-&gt;next = v-&gt;next, v-&gt;next = p; // p向后挪动一位 p = q; &#125; return dummy-&gt;next; &#125;&#125;;","categories":[],"tags":[]},{"title":"Leetcode134. 加油站","slug":"lc-134","date":"2020-11-17T16:00:00.000Z","updated":"2020-11-20T00:14:59.749Z","comments":true,"path":"lc-134/","link":"","permalink":"http://example.com/lc-134/","excerpt":"题目134. 加油站","text":"题目134. 加油站 算法一 模拟 O(n^2)枚举所有起点，然后计算是否能转一圈回来。 代码C++12345678910111213141516171819202122class Solution &#123;public: int canCompleteCircuit(vector&lt;int&gt;&amp; gas, vector&lt;int&gt;&amp; cost) &#123; int n = gas.size(); // 枚举所有起点 for(int i = 0; i &lt; n; i ++ )&#123; bool flag = true; // 枚举所有能到达的站点 for(int j = 0, r = 0; flag &amp;&amp; j &lt; n; j ++ )&#123; // 计算站点坐标 int k = (i + j) % n; // 计算要消耗和能获得的燃油量 r += gas[k] - cost[k]; // 如果r&lt;0则表示不能到达下一站,置flag为false if(r &lt; 0) flag = false; &#125; // 如果flag = true，则表示能转一圈回来。 if(flag) return i; &#125; return -1; &#125;&#125;; Java123456789101112131415161718192021class Solution &#123; public int canCompleteCircuit(int[] gas, int[] cost) &#123; int n = gas.length; // 枚举所有起点 for(int i = 0; i &lt; n; i ++ )&#123; boolean flag = true; // 枚举所有能到达的站点 for(int j = 0, r = 0; flag &amp;&amp; j &lt; n; j ++ )&#123; // 计算站点坐标 int k = (i + j) % n; // 计算要消耗和能获得的燃油量 r += gas[k] - cost[k]; // 如果r&lt;0则表示不能到达下一站,置flag为false if(r &lt; 0) flag = false; &#125; // 如果flag = true，则表示能转一圈回来。 if(flag) return i; &#125; return -1; &#125;&#125; 算法二 模拟（优化）O(n)考虑一种失败的情况，我们从点i出发，最多可以到达点k（还未转一圈到达点i）。也就是说我们一共经过了i, i + 1, i + 2, … , k - 2, k - 1, k这些站点；根据题意，我们刚刚到达这些站点的时候，一定是满足r&gt;=0的，因为如果r &lt; 0,我们就没有油可以到达这个站点了。 而在上一个算法中，我们会枚举所有这些中间节点，但是其实这些中间节点都是不需要枚举的，因为在以i为起点的时候，到达所有这些中间节点的时候满足r &gt;= 0, 这样都最远只能到达点k，而我们如果枚举这些中间节点的时候，设置r = 0,这些点就不可能到达超过点k的位置了。 综上，如果遇到失败的情况，我们跳过所有中间节点。 代码C++1234567891011121314151617181920class Solution &#123;public: int canCompleteCircuit(vector&lt;int&gt;&amp; gas, vector&lt;int&gt;&amp; cost) &#123; int n = gas.size(); // 注意，没有i++ for(int i = 0; i &lt; n;)&#123; bool flag = true; int j = 0; // 失败的时候需要用j计算跳过的节点 for(int r = 0; flag &amp;&amp; j &lt; n; j ++ )&#123; int k = (i + j) % n; r += gas[k] - cost[k]; if(r &lt; 0) flag = false; &#125; if(flag) return i; // 注意,因为置flag还要继续循环一次，所以j会+1,i+=j就是跳过了所有中间节点。 i += j; &#125; return -1; &#125;&#125;; Java12345678910111213141516171819class Solution &#123; public int canCompleteCircuit(int[] gas, int[] cost) &#123; int n = gas.length; // 注意，没有i++ for(int i = 0; i &lt; n;)&#123; boolean flag = true; int j = 0; for(int r = 0; flag &amp;&amp; j &lt; n; j ++ )&#123; int k = (i + j) % n; r += gas[k] - cost[k]; if(r &lt; 0) flag = false; &#125; if(flag) return i; // 注意,因为置flag还要继续循环一次，所以j会+1,i+=j就是跳过了所有中间节点。 i += j; &#125; return -1; &#125;&#125;","categories":[],"tags":[]},{"title":"Leetcode1030. 距离顺序排列矩阵单元格","slug":"lc-1030","date":"2020-11-16T16:00:00.000Z","updated":"2020-11-18T05:21:52.625Z","comments":true,"path":"lc-1030/","link":"","permalink":"http://example.com/lc-1030/","excerpt":"题目1030. 距离顺序排列矩阵单元格","text":"题目1030. 距离顺序排列矩阵单元格 思路排序 O(RClog(RC))先把所有点加到数组中，然后按照到给定点的曼哈顿距离进行排序 代码C++12345678910111213141516class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; allCellsDistOrder(int R, int C, int r0, int c0) &#123; vector&lt;vector&lt;int&gt;&gt; res; // 把所有点插入进去 for(int i = 0; i &lt; R; i ++ ) for(int j = 0; j &lt; C; j ++ ) res.push_back(&#123;i, j&#125;); // 按照曼哈顿距离排序 sort(res.begin(), res.end(), [&amp;](vector&lt;int&gt; a, vector&lt;int&gt; b)-&gt;bool&#123; int d1 = abs(a[0] - r0) + abs(a[1] - c0); int d2 = abs(b[0] - r0) + abs(b[1] - c0); return d1 &lt; d2; &#125;); return res; &#125;&#125;; Java123456789101112131415161718class Solution &#123; public int[][] allCellsDistOrder(int R, int C, int r0, int c0) &#123; ArrayList&lt;int[]&gt; res = new ArrayList&lt;&gt;(); // 把所有点插入进去 for(int i = 0; i &lt; R; i ++ ) for(int j = 0; j &lt; C; j ++ ) res.add(new int[]&#123;i, j&#125;); // 按照曼哈顿距离排序 Collections.sort(res, new Comparator&lt;int[]&gt;()&#123; public int compare(int[] a, int b[])&#123; int d1 = Math.abs(a[0] - r0) + Math.abs(a[1] - c0); int d2 = Math.abs(b[0] - r0) + Math.abs(b[1] - c0); return d1 - d2; &#125; &#125;); return res.toArray(new int[R * C][2]); &#125;&#125; BFS O(RC)从原点开始，按照BFS进行搜索，逐个加入答案数组中 代码C++12345678910111213141516171819202122232425262728293031class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; allCellsDistOrder(int R, int C, int r0, int c0) &#123; // 表示右边、上边、下边、左边点的坐标的偏移量 int dx[] = &#123;0, 1, 0, -1&#125;, dy[] = &#123;1, 0, -1, 0&#125;; queue&lt;int&gt; q; unordered_set&lt;int&gt; st; vector&lt;vector&lt;int&gt;&gt; res; // 把（x, y）坐标压缩成一个整数，范围都在[0, 100] // BFS队列 q.push(r0 * 100 + c0); // 记录那些点入过队，防止重复入队 st.insert(r0 * 100 + c0); while(q.size())&#123; auto t = q.front(); q.pop(); int x = t / 100, y = t % 100; // 将点加入答案中 res.push_back(&#123;x, y&#125;); // 遍历所有相邻节点 for(int i = 0; i &lt; 4; i ++ )&#123; int a = x + dx[i], b = y + dy[i]; int c = a * 100 + b; // 如果坐标不合法或者该坐标之前被加入过到队列中，跳过。 if(a &lt; 0 || a &gt;= R || b &lt; 0 || b &gt;= C || st.count(c)) continue; q.push(c); st.insert(c); &#125; &#125; return res; &#125;&#125;; Java12345678910111213141516171819202122232425262728293031323334class Solution &#123; public int[][] allCellsDistOrder(int R, int C, int r0, int c0) &#123; // 表示右边、上边、下边、左边点的坐标的偏移量 int[] dx = &#123;0, 1, 0, -1&#125;; int[] dy = &#123;1, 0, -1, 0&#125;; // 答案数组 ArrayList&lt;int[]&gt; res = new ArrayList&lt;&gt;(); // BFS使用的队列 Queue&lt;Integer&gt; q = new LinkedList&lt;&gt;(); // 标记哪些点已经入过队 Set&lt;Integer&gt; st = new HashSet(); // 因为坐标的范围在[0, 100],所以可以将坐标压缩成一个整数 x * 100 + y q.offer(r0 * 100 + c0); st.add(r0 * 100 + c0); // BFS while(q.size() &gt; 0)&#123; // 出队 int t = q.poll(); int x = t / 100, y = t % 100; // 加入到答案当中 res.add(new int[]&#123;x, y&#125;); // 遍历所有相邻节点 for(int i = 0; i &lt; 4; i ++ )&#123; int a = x + dx[i], b = y + dy[i]; int c = a * 100 + b; // 如果坐标不合法或者该坐标之前被加入过到队列中，跳过。 if(a &lt; 0 || a &gt;= R || b &lt; 0 || b &gt;= C || st.contains(c)) continue; q.offer(c); st.add(c); &#125; &#125; return (int[][])res.toArray(new int[R*C][2]); &#125;&#125; 附录 C++重载运算符1234567891011121314151617181920212223242526272829// 声明成staticstatic int r0, c0;class Solution &#123;public: struct Node&#123; vector&lt;int&gt; coord; // 重载运算符 bool operator&lt;(Node b)&#123; int d1 = abs(coord[0] - r0) + abs(coord[1] - c0); int d2 = abs(b.coord[0] - r0) + abs(b.coord[1] - c0); return d1 &lt; d2; &#125; Node(int x, int y)&#123; coord = &#123;x, y&#125;; &#125; &#125;; vector&lt;vector&lt;int&gt;&gt; allCellsDistOrder(int R, int C, int _r0, int _c0) &#123; r0 = _r0, c0 = _c0; vector&lt;Node&gt; points; for(int i = 0; i &lt; R; i ++ ) for(int j = 0; j &lt; C; j ++ ) points.push_back(Node(i, j)); sort(points.begin(), points.end()); vector&lt;vector&lt;int&gt;&gt; res; for(auto p : points)&#123; res.push_back(p.coord); &#125; return res; &#125;&#125;;","categories":[],"tags":[]},{"title":"Leetcode406. 根据身高重建队列","slug":"lc-406","date":"2020-11-15T16:00:00.000Z","updated":"2020-11-16T01:58:16.789Z","comments":true,"path":"lc-406/","link":"","permalink":"http://example.com/lc-406/","excerpt":"题目406. 根据身高重建队列","text":"题目406. 根据身高重建队列 思路排序+模拟题目给定元素包含{h, k}两个关键字，然后进行排序，排序的规则是： 对于元素peoplei，它前面的i - 1个元素 peoplej(0","categories":[],"tags":[]},{"title":"Leetcode402. 移掉K位数字","slug":"lc-402","date":"2020-11-14T16:00:00.000Z","updated":"2020-11-15T08:49:25.937Z","comments":true,"path":"lc-402/","link":"","permalink":"http://example.com/lc-402/","excerpt":"","text":"题目402. 移掉K位数字 思路贪心+单调栈 O(n)算法给定数字: D0 D1 D2 D3 ... Dn - 1 Dn 我们从中删掉k位，使剩余的数字组成最小值。我们可以使用贪心+单调栈的算法。 首先，对于任意的Di和Di - 1，如果说Di&gt;Di - 1,那么我们就选择将Di删掉，因为如果不删的话那么最终的数字就是xxxDi****,而删掉的话，最终的数字是xxxDi - 1 ****，因为两者最终剩余的位数都是一样的，由因为Di&gt;Di - 1，所以xxxDi****一定是大于xxxDi - 1 ****的。 综上，对于任意的Di和Di - 1，如果说Di&gt;Di - 1,那么我们就选择将Di删掉。 单调栈单调栈，是指栈内元素是单调递增或者单调递减的栈。在本题中，我们遍历数字的每一位，在将这一位数字压入栈之前，我们先将其与栈顶元素进行比较，如果说栈尾元素大于当前元素，就将栈尾元素pop出去，这样，我们就能保证栈内元素是单调递增的。 代码C++123456789101112131415161718192021class Solution &#123;public: string removeKdigits(string nums, int k) &#123; int n = nums.size(); string res; // 遍历每一位 for(int i = 0; i &lt; n; i ++ )&#123; // 单调栈，如果栈尾元素大于当前元素，就将栈尾元素pop出去 while(res.size() &amp;&amp; res.back() &gt; nums[i] &amp;&amp; k) res.pop_back(), k -- ; res.push_back(nums[i]); &#125; // 如果还需要删字符，因为栈中元素是单增的，所以从尾部开始删除 while(res.size() &amp;&amp; k) res.pop_back(), k -- ; // 去除前导零 while(res.size() &amp;&amp; res.front() == &#x27;0&#x27;) res.erase(res.begin()); // 所有数字都被删掉了 if(!res.size()) res = &quot;0&quot;; return res; &#125;&#125;; Java12345678910111213141516171819202122232425class Solution &#123; public String removeKdigits(String num, int k) &#123; StringBuilder res = new StringBuilder(); // 遍历每一位 for(int i = 0; i &lt; num.length(); i ++ )&#123; char c = num.charAt(i); // 单调栈，如果栈尾元素大于当前元素，就将栈尾元素pop出去 while(res.length() != 0 &amp;&amp; res.charAt(res.length() - 1) &gt; c &amp;&amp; k != 0)&#123; res.deleteCharAt(res.length() - 1); k -- ; &#125; res.append(c); &#125; // 如果还需要删字符，因为栈中元素是单增的，所以从尾部开始删除 while(k != 0 &amp;&amp; res.length() != 0)&#123; res.deleteCharAt(res.length() - 1); k -- ; &#125; // 去除前导零 while(res.length() != 0 &amp;&amp; res.charAt(0) == &#x27;0&#x27;) res.deleteCharAt(0); // 所有数字都被删掉了 if(res.length() == 0) res = new StringBuilder(&quot;0&quot;); return res.toString(); &#125;&#125;","categories":[],"tags":[]},{"title":"Leetcode1122. 数组的相对排序","slug":"lc-1122","date":"2020-11-13T16:00:00.000Z","updated":"2020-11-14T15:26:33.612Z","comments":true,"path":"lc-1122/","link":"","permalink":"http://example.com/lc-1122/","excerpt":"题目1122. 数组的相对排序","text":"题目1122. 数组的相对排序 思路将arr1中的元素按照arr2中的元素的出现顺序排序，如果没有出现过，就按大小排序 代码C++123456789101112131415161718class Solution &#123;public: vector&lt;int&gt; relativeSortArray(vector&lt;int&gt;&amp; arr1, vector&lt;int&gt;&amp; arr2) &#123; unordered_map&lt;int, int&gt; idx; for(int i = 0; i &lt; arr2.size(); i ++ ) idx[arr2[i]] = i; sort(arr1.begin(), arr1.end(), [&amp;](int a, int b)-&gt;bool&#123; // 如果都没在arr2中元素出现过，按大小排序 if(!idx.count(a) &amp;&amp; !idx.count(b)) return a &lt; b; // a没在arr2出现过，a放在数组后面 if(!idx.count(a)) return false; // b没在arr2出现过，a放在数组前面 if(!idx.count(b)) return true; // 都在arr2出现过，出现在arr2前面的排在前面 return idx[a] &lt; idx[b]; &#125;); return arr1; &#125;&#125;; Java1234567891011121314151617181920212223class Solution &#123; public int[] relativeSortArray(int[] arr1, int[] arr2) &#123; Map&lt;Integer, Integer&gt; idx = new HashMap&lt;&gt;(); for(int i = 0; i &lt; arr2.length; i ++ ) idx.put(arr2[i], i); ArrayList&lt;Integer&gt; array1 = new ArrayList&lt;Integer&gt;(); for(int t : arr1) array1.add(t); Collections.sort(array1, new Comparator&lt;Integer&gt;()&#123; public int compare(Integer a, Integer b)&#123; // 如果都没在arr2中元素出现过，按大小排序 if(!idx.containsKey(a) &amp;&amp; !idx.containsKey(b)) return a - b; // a没在arr2出现过，a放在数组后面 if(!idx.containsKey(a)) return 1; // b没在arr2出现过，a放在数组前面 if(!idx.containsKey(b)) return -1; // 都在arr2出现过，出现在arr2前面的排在前面 return idx.get(a) - idx.get(b); &#125; &#125;); for(int i = 0; i &lt; array1.size(); i ++) arr1[i] = array1.get(i); return arr1; &#125;&#125;","categories":[],"tags":[]},{"title":"Leetcode328. 奇偶链表","slug":"lc-328","date":"2020-11-12T16:00:00.000Z","updated":"2020-11-13T06:53:34.799Z","comments":true,"path":"lc-328/","link":"","permalink":"http://example.com/lc-328/","excerpt":"题目328. 奇偶链表","text":"题目328. 奇偶链表 思路遍历链表，把链表按照序号的奇偶拆分成两个链表。然后把包含偶数节点的链表接到奇数节点链表的后边。 代码C++123456789101112131415161718192021222324class Solution &#123;public: ListNode* oddEvenList(ListNode* head) &#123; // 头节点：d1指向包含奇数节点的链表， d2指向包含偶数节点的链表 auto d1 = new ListNode(-1), d2 = new ListNode(-1); // 尾插法 auto r1 = d1, r2 = d2; // 遍历链表 auto p = head; while(p)&#123; // 奇数节点插入到d1指向的链表 auto q = p-&gt;next; r1 = r1-&gt;next= p; p = p-&gt;next; if(!p) break; // 偶数节点插入到d1指向的链表 r2 = r2-&gt;next = p; p = p-&gt;next; &#125; // 偶数链表接到奇数链表后面 r1-&gt;next = d2-&gt;next, r2-&gt;next = NULL; return d1-&gt;next; &#125;&#125;; Java1234567891011121314151617181920class Solution &#123; public ListNode oddEvenList(ListNode head) &#123; // 头节点：d1指向包含奇数节点的链表， d2指向包含偶数节点的链表 ListNode d1 = new ListNode(-1), d2 = new ListNode(-1); // 尾插法 ListNode r1 = d1, r2 = d2; // 遍历链表 for(ListNode p = head; p != null;)&#123; r1 = r1.next = p; p = p.next; if(p == null) break; r2 = r2.next = p; p = p.next; &#125; // 偶数链表接到奇数链表后面 r1.next = d2.next; r2.next = null; return d1.next; &#125;&#125;","categories":[],"tags":[]},{"title":"Leetcode922. 按奇偶排序数组 II","slug":"lc-922","date":"2020-11-12T16:00:00.000Z","updated":"2020-11-13T06:49:14.589Z","comments":true,"path":"lc-922/","link":"","permalink":"http://example.com/lc-922/","excerpt":"题目922. 按奇偶排序数组 II","text":"题目922. 按奇偶排序数组 II 思路&amp;代码双指针将数组按照下标的奇偶分为两部分，然后用两个指针i，j分别遍历，如果i遍历到奇数就停下来，j遍历到偶数也停下来，然后交换两个指针指向的元素值。 C++1234567891011121314class Solution &#123;public: vector&lt;int&gt; sortArrayByParityII(vector&lt;int&gt;&amp; A) &#123; for(int i = 0, j = 1; i &lt; A.size() &amp;&amp; j &lt; A.size();)&#123; while(i &lt; A.size() &amp;&amp; A[i] % 2 == 0) i += 2; while(j &lt; A.size() &amp;&amp; A[j] % 2 == 1) j += 2; if(i &lt; A.size() &amp;&amp; j &lt; A.size())&#123; swap(A[i], A[j]); i += 2, j += 2; &#125; &#125; return A; &#125;&#125;; Java123456789101112131415161718192021class Solution &#123; int[] A; public void swap(int i, int j)&#123; int t = A[i]; A[i] = A[j]; A[j] = t; &#125; public int[] sortArrayByParityII(int[] _A) &#123; A = _A; for(int i = 0, j = 1; i &lt; A.length &amp;&amp; j &lt; A.length; )&#123; while(i &lt; A.length &amp;&amp; A[i] % 2 == 0) i += 2; while(j &lt; A.length &amp;&amp; A[j] % 2 == 1) j += 2; if(i &lt; A.length &amp;&amp; j &lt; A.length)&#123; swap(i, j); i += 2; j += 2; &#125; &#125; return A; &#125;&#125; 双指针+虚地址与上个方法的双指针不同的是，这种方法的双指针是将偶数排在数组的后半部分，奇数排在前半部分。然后我们只要把奇偶数交叉的放到数组里就可以了。 上面的算法很简单，我们可以用虚地址的方法，把数组下标重新映射一下，将前后半坐标直接映射成交叉排列，这样我们就可以直接对使用上述的双指针算法将虚地址空间中的奇数排列在前半部分，偶数排在后半部分，最后在实际的数组中就可以得到我们想要的交叉排列的数组了。虚地址映射函数如下： f(i) = (2 * (i)+ 1) % (n | 1) 举一个例子，设n = 6: C++1234567891011121314151617class Solution &#123;public: int n; // 虚地址映射函数 #define N(i) A[(1+2*(i)) % (n|1)] vector&lt;int&gt; sortArrayByParityII(vector&lt;int&gt;&amp; A) &#123; n = A.size(); // 将虚地址空间中的奇数排列在前半部分，偶数排在后半部分 for(int i = 0, j = n - 1; i &lt; j;)&#123; while(N(i) % 2 == 1) i ++ ; while(N(j) % 2 == 0) j -- ; if(i &lt; j) swap(N(i ++ ), N(j -- )); &#125; return A; &#125;&#125;; Java12345678910111213141516171819202122232425262728class Solution &#123; int[] A; int n; // 在虚地址空间中交换 void swap(int i, int j)&#123; i = (2 * i + 1) % (n | 1); j = (2 * j + 1) % (n | 1); int t = A[i]; A[i] = A[j]; A[j] = t; &#125; // 虚地址映射函数 int f(int i)&#123; return A[(2 * i + 1) % (n | 1)]; &#125; public int[] sortArrayByParityII(int[] _A) &#123; A = _A; n = A.length; // 将虚地址空间中的奇数排列在前半部分，偶数排在后半部分 for(int i = 0, j = n - 1; i &lt; j; i ++, j -- )&#123; while(i &lt; j &amp;&amp; f(i) % 2 == 1) i ++ ; while(i &lt; j &amp;&amp; f(j) % 2 == 0) j -- ; if(i &lt; j) swap(i, j); &#125; return A; &#125;&#125;","categories":[],"tags":[]},{"title":"Leetcode514.自由之路","slug":"lc-514","date":"2020-11-11T16:00:00.000Z","updated":"2020-11-13T06:54:17.060Z","comments":true,"path":"lc-514/","link":"","permalink":"http://example.com/lc-514/","excerpt":"题目514. 自由之路","text":"题目514. 自由之路 思路动态规划设:f[i][j]为匹配了key[0:i],且ring[j]在最上方需要转动的最小次数。 对于每一个f[i][j], 我们先考虑i和j应该满足什么样的要求? 因为我们匹配的是key[i],为了得到最小的步骤，我们只需要将ring[j] = key[i]的位置j转到最上方就可以了，因为对于那些ring[k] != key[i]的位置，我们就需要先将圆环的ring[j]（ring[j] == key[i]）转到最上方,将key[i]进行匹配之后,再从这个位置把ring[k]再转到最上方。这个动作是多余的。在后面我们也能看到，对于那些f[i][j],其中ring[j] != key[i]的这些状态，我们是不需要的。 综上，我们只需要维护f[i][j]其中key[i] = ring[j]。 然后如何进行状态转移呢？如何得到f[i][j]呢？ 我们先考虑最后一步，我们的目的是匹配key[i],并且将ring[j]转到最上方。那么我们应该从什么地方开始转动呢？很容易想到，我们在进行这次转动之前，我们匹配了key[i - 1]，所以我们就要从那些ring[k] = key[i - 1]的位置k开始，将ring[j]转换到最上方。 综上，我们将圆环从ring[k]在最上方，转动到了ring[j]在最上方。其中ring[k] = key[i - 1],ring[j] = key[i]。 最后，如果将圆环从位置j转到位置k，我们最少需要转动多少步呢？ 要将圆环从位置j转到位置k，我们需要将圆环转动abs(j - k)步，但是圆环可以顺时针转动，也可以逆时针转动，所以要反方向转动，就需要将圆环转动m - abs(j - k)步。 综上，要将圆环从位置j转到位置k，我们最少需要转动min(abs(j - k), m - abs(j - k))步。 代码C++1234567891011121314151617181920212223242526272829class Solution &#123;public: int findRotateSteps(string ring, string key) &#123; int n = key.size(), m = ring.size(); // f[i][j]:匹配key[0:i]，ring[j]在十二点钟方向，需要转的最少步数 vector&lt;vector&lt;int&gt;&gt; f(n, vector&lt;int&gt;(m, 2e9)); // pos:存储各个字母在ring中的位置 vector&lt;vector&lt;int&gt;&gt; pos(26); for(int i = 0; i &lt; m; i ++ ) pos[ring[i] - &#x27;a&#x27;].push_back(i); //初始化：匹配key[0]，如果ring[i]要转到十二点方向，需要的最少步数 for(auto i : pos[key[0] - &#x27;a&#x27;]) f[0][i] = min(i, m - i); // 动态规划 for(int i = 1; i &lt; n; i ++ ) // 枚举key[i]在ring中出现的位置 for(auto j : pos[key[i] - &#x27;a&#x27;]) // 枚举key[i - 1]在ring中出现的位置 for(auto k : pos[key[i - 1] - &#x27;a&#x27;])&#123; // 要从位置k转到位置j f[i][j] = min(f[i][j], f[i - 1][k] + min(abs(k - j), m - abs(k - j))); &#125; // 找到匹配key需要的最少步数 int res = 2e9; for(int i = 0; i &lt; m; i ++ ) res = min(res, f[n - 1][i]); // 每次匹配需要按动一次按钮，相当于转动一次，所以要加上key.size() return res + n; &#125;&#125;; Java1234567891011121314151617181920212223242526class Solution &#123; public int findRotateSteps(String ring, String key) &#123; int n = key.length(), m = ring.length(); // pos数组：存储各个字母在ring中的位置 ArrayList&lt;Integer&gt;[] pos = new ArrayList[26]; for(int i = 0; i &lt; 26; i ++ ) pos[i] = new ArrayList(); for(int i = 0; i &lt; m; i ++ ) pos[ring.charAt(i) - &#x27;a&#x27;].add(i); // f[i][j]:匹配key[0:i]，ring[j]在十二点钟方向，需要转的最少步数 int[][] f = new int[n][m]; // 初始化：注意在java中如果2e9表示一个常量，需要强制转换为int类型 for(int i = 0; i &lt; n; i ++ ) Arrays.fill(f[i], (int)2e9); // 初始化：匹配key[0]，如果ring[i]要转到十二点方向，需要的最少步数 for(int i : pos[key.charAt(0) - &#x27;a&#x27;]) f[0][i] = Math.min(i, m - i); // 动态规划 for(int i = 1; i &lt; n; i ++ ) // 枚举key[i]在ring中出现的位置 for(int j : pos[key.charAt(i) - &#x27;a&#x27;]) // 枚举key[i - 1]在ring中出现的位置 for(int k : pos[key.charAt(i - 1) - &#x27;a&#x27;]) // 从位置k转到位置j f[i][j] = Math.min(f[i][j], f[i - 1][k] + Math.min(Math.abs(j - k), m - Math.abs(j - k))); // java中的流式编程，找到f[n - 1]中最小的元素 return Arrays.stream(f[n - 1]).min().getAsInt() + n; &#125;&#125;","categories":[],"tags":[]},{"title":"Leetcode31. 下一个排列","slug":"lc-31","date":"2020-11-09T16:00:00.000Z","updated":"2020-11-13T06:53:12.870Z","comments":true,"path":"lc-31/","link":"","permalink":"http://example.com/lc-31/","excerpt":"题目31. 下一个排列","text":"题目31. 下一个排列 思路我们这道题是要找到一个给定的数的下一个排列，也就是找到同样由给定的数的各位数字排列而成的最小的大于给定的数的数。 先给出算法的步骤： 从后往前，扫描数组nums，找到最小的j使得nums[i: n]是降序（不升序）排列的。 如果i == 0,说明整个数组降序（不升序）排列，逆转整个数组之后输出。 在nums[i: n]中找到一个最小的大于nums[i - 1]的数，并将其与nums[i - 1]对换。 将nums[i: n]翻转。 然后举个例子，对于数字123我们可以很简单的找到比它大的数132, 312, ….;而它的下一个排列就是132。132就是由1， 2， 3三位数组成的最小的比123大的数字。 然后我们先想一下特殊情况，什么样的数字是没有比他大的下一个排列的呢？那就是一个从低位到高位升序或者不降序排列的数。比如说321,它就是由1， 2， 3三位数字组成的最大数了。遇到这种情况我们应该怎么办呢？我们要给出由这三位数给出的最小排列，也就是123，我们只需要一个排序就搞定了。 12vector&lt;int&gt; a = &#123;3, 2, 1&#125;;sort(a.begin(), a.end()); // &#123;1, 2, 3&#125; 那么对于更一般的情况，我们怎么找到其下一个排列呢？题目的要求是找到比当前数大的最小排列。要做到这一点，我们就要尽量的保持高位不变，然后让低位变动的幅度最小。 为了做到这一点，我们先从低位开始扫描，如果遇到第一个不符合升序或者不降序排列，我们就停下来。例如：1247664，我们从4开始扫描，7664从低到高都是不降序排列的。但是到47664中的4, 因为4&lt;7，所以到7，我们就停下来。 因为在上面我们说的，一个升序或者不降序排列的数，是没有比它大的下一个排列的，所以我们就把它的下一个数包括进来，在上例就是47664, 然后我们找比它大的下一个排列就可以了。 这个问题很简单，我们只要在7664里面找到一个比4大的最小的数,也就是6, 将两者交换，变为67644,因为任意6开头的数字, 都比47664要大，而我们想要的是最小的，因为这个数（7664）仍然是升序或者不降序排列的数，所以我们就把7644翻转,变为4467，然后就可以得到64467这个比47664大的最小排列了。 最后，高位不用动，就能得到我们想要的最小排列了。在本例中，也就是1264467。 代码C++12345678910111213141516171819class Solution &#123;public: void nextPermutation(vector&lt;int&gt;&amp; nums) &#123; int i = nums.size() - 1; // 从后往前扫描数组，找到最小的j使得nums[j: n]是降序（不升序）排列的。 while(i &amp;&amp; nums[i - 1] &gt;= nums[i]) i -- ; // 如果j == 0,说明整个数组降序（不升序）排列，逆转整个数组之后输出。 // 否则进行下列操作 if(i)&#123; // 在nums[j: n]中找到一个最小的大于nums[j - 1]的数，并将其与nums[j - 1]对换。 int k = nums.size() - 1; while(nums[k] &lt;= nums[i - 1]) k -- ; swap(nums[k], nums[i - 1]); &#125; // 进行响应的翻转 // 注意，此时i可以为0也可以不是0. reverse(nums.begin() + i, nums.end()); &#125;&#125;; Java123456789101112131415161718192021222324252627class Solution &#123; public void swap(int[] a, int i, int j)&#123; int t = a[i]; a[i] = a[j]; a[j] = t; &#125; public void reverse(int[] a, int start)&#123; for(int i = start, j = a.length - 1; i &lt; j; i ++, j -- ) swap(a, i, j); &#125; public void nextPermutation(int[] nums) &#123; int i = nums.length - 1; // 从后往前扫描数组，找到最小的j使得nums[j: n]是降序（不升序）排列的。 while(i &gt; 0 &amp;&amp; nums[i] &lt;= nums[i - 1]) i -- ; // 如果j == 0,说明整个数组降序（不升序）排列，逆转整个数组之后输出。 // 否则进行下列操作 if(i &gt; 0)&#123; // 在nums[j: n]中找到一个最小的大于nums[j - 1]的数，并将其与nums[j - 1]对换。 int k = nums.length - 1; while(nums[k] &lt;= nums[i - 1]) k -- ; swap(nums, i - 1, k); &#125; // 进行响应的翻转 // 注意，此时i可以为0也可以不是0. reverse(nums, i); &#125;&#125;","categories":[],"tags":[],"author":"李拓"},{"title":"Leetcode973. 最接近原点的 K 个点","slug":"lc-973","date":"2020-11-08T16:00:00.000Z","updated":"2020-11-13T06:54:57.726Z","comments":true,"path":"lc-973/","link":"","permalink":"http://example.com/lc-973/","excerpt":"题目973. 最接近原点的 K 个点","text":"题目973. 最接近原点的 K 个点 思路排序，然后输出前k个点。 代码1234567891011121314class Solution &#123;public: typedef long long LL; vector&lt;vector&lt;int&gt;&gt; kClosest(vector&lt;vector&lt;int&gt;&gt;&amp; points, int K) &#123; sort(points.begin(), points.end(), [](vector&lt;int&gt;&amp; a, vector&lt;int&gt;&amp; b)-&gt;bool&#123; // 按照到原点的距离从小到大排序 LL d1 = a[0] * a[0] + a[1] * a[1], d2 = b[0] * b[0] + b[1] * b[1]; return d1 &lt;= d2; &#125;); // 去掉多余的点 points.erase(points.begin() + K, points.end()); return points; &#125;&#125;;","categories":[],"tags":[]},{"title":"Leetcode122.买卖股票的最佳时机Ⅱ","slug":"lc-122","date":"2020-11-07T16:00:00.000Z","updated":"2020-11-13T06:52:37.447Z","comments":true,"path":"lc-122/","link":"","permalink":"http://example.com/lc-122/","excerpt":"题目122. 买卖股票的最佳时机 II","text":"题目122. 买卖股票的最佳时机 II 贪心 O(n)如果我们选择在第i天买入，在第j天卖出，我们的收益就是prices[j] - prices[i], 容易得出： 123prices[j] - prices[i]= prices[i + 1] - prices[i] + prices[i + 2] - prices[i + 1] + ... + prices[j] - prices[j - 1]= (prices[i + 1] - prices[i]) + (prices[i + 2] - prices[i + 1]) + ... + (prices[j] - prices[j - 1]) 也就是说，我们在两个第i天买入，第j天卖出所获得的收益就等于在第i天买入，第i+1天卖出之后再买入，然后第i+2天卖出再买入, 直到第j天至卖出不买入的收益。 那么我们如何最大化第i天到第j天的收入呢？对于任意prices[k + 1] - prices[k]，只能有三种情况： 小于0，也就是说卖出价格低于前一天买入价格，这样交易是亏钱的。 等于0，也就是说卖出价格等于前一天的买入价格，这样交易不亏不赚。 大于0，也就是说卖出价格大于前一天的买入价格，这样交易是赚钱的。 显然，我们只要抓住每次赚钱的机会，这样就可以保证我们可以赚到最多的钱了。 代码12345678910class Solution &#123;public: int maxProfit(vector&lt;int&gt;&amp; prices) &#123; int res = 0; for(int i = 0; i + 1 &lt; prices.size(); i ++ ) // 只选择赚钱的交易 if(prices[i + 1] &gt; prices[i]) res += prices[i + 1] - prices[i]; return res; &#125;&#125;; 动态规划我们还可以使用状态机动态规划来解决股票问题。我们可以设定两个状态：状态0：未持有股票和状态1: 持有股票;两个状态的状态表示以及状态转移： 如果我们未持有股票，我们就需要prices[i]去获得股票，如果我们持有股票，我们就可以卖掉获得prices[i]。因为一开始我们是未持有股票的，所以状态机的入口是状态0. 代码12345678910111213141516171819class Solution &#123;public: int maxProfit(vector&lt;int&gt;&amp; prices) &#123; int n = prices.size(); // dp[i][j]：第i天，处于状态j可以获得的最大收益 vector&lt;vector&lt;int&gt;&gt; dp(n + 1, vector&lt;int&gt;(2)); // 因为入口是状态0，所以将第0天状态1设置为-2e9(负无穷)，使其只能从状态0转移。 dp[0][1] = -2e9; // 枚举每一天 for(int i = 1; i &lt;= n; i ++ )&#123; // 状态转移方程是根据状态机中的边写出来的 // 第i天，未持有股票获得的最大收益 = max(第i - 1天未持有股票的最大收益，第i - 1天持有股票并卖出股票) dp[i][0] = max(dp[i - 1][0], dp[i - 1][1] + prices[i - 1]); // 第i天，持有股票获得的最大收益 = max(第i - 1天持有股票的最大收益，第i - 1天未持有股票并买入股票) dp[i][1] = max(dp[i - 1][1], dp[i - 1][0] - prices[i - 1]); &#125; return dp[n][0]; &#125;&#125;;","categories":[],"tags":[]},{"title":"Leetcode327. 区间和的个数","slug":"lc-327","date":"2020-11-07T16:00:00.000Z","updated":"2020-11-13T06:53:23.835Z","comments":true,"path":"lc-327/","link":"","permalink":"http://example.com/lc-327/","excerpt":"题目327. 区间和的个数","text":"题目327. 区间和的个数 思路 &amp; 代码要求一个数组的某一区间和，我们可以利用前缀和算法。 设：数组nums是下标从1~n的数组，那么他的前缀和就是sum[i] = nums[1] + nums[2] + nums[3] + ... + nums[i]，我们可以用下面的代码实现： 1for(int i = 1; i &lt;= n; i ++ ) sum[i] = sum[i - 1] + nums[i]; 因为本题的nums数组是从0开始的，所以我们可以稍微修改一下（sum数组仍然从1开始）： 1for(int i = 1; i &lt;= n; i ++ ) sum[i] = sum[i - 1] + nums[i - 1]; 那么有了sum数组，我们就可以在O(1)的时间复杂度查询到任意区间内的区间和： 1sum[j : i] = sum[i] - sum[j - 1] = nums[j] + nums[j + 1] + ... + nums[i - 1] + nums[i] 本体的题意是找到区间[i, j]的区间和sum[j : i]和在给定范围的区间个数，也就是说，找到所有满足下列公式的区间： 123lower &lt;= sum[i] - sum[j] &lt;= upper; 1 &lt;= i &lt;= n, 0 &lt;= j &lt;= i - 1;等价变换：sum[i] - upper &lt;= sum[j] &lt;= sum[i] - lower; ---- 公式1 所以，我们的任务就是对于每一个sum[i], 找到满足公式1的sum[j]的个数; 我们可以通过这个思路写出一个时间复杂度为O(n^2)的算法,代码如下： 朴素版 O(n^2)12345678910111213141516171819class Solution &#123;public: typedef long long LL; int countRangeSum(vector&lt;int&gt;&amp; nums, int lower, int upper) &#123; int n = nums.size(); vector&lt;LL&gt; sum(n + 1); // 求区间和 for(int i = 1; i &lt;= n; i ++) sum[i] = sum[i - 1] + nums[i - 1]; int res = 0; // 对于每一个sum[i], 找到满足`公式1`的sum[j]的个数 for(int i = 1; i &lt;= n; i ++)&#123; LL a = sum[i] - upper, b = sum[i] - lower; for(int j = 0; j &lt; i; j ++ ) if(a &lt;= sum[j] &amp;&amp; sum[j] &lt;= b) res ++ ; &#125; return res; &#125;&#125;; 但是这样做会TLE，所以我们就要通过一些方法优化一下时间复杂度。我们可以想象一个容器，我们可以把数插入进去，然后在很短的时间内，查询到这个容器中有多少个数是在给定范围的。如果存在这样一个数据结构，我们就可以很方便的遍历前缀和数组sum,然后查询容器中有多少数是在范围[sum[i] - upper, sum[i] - lower]中的，然后我们再将sum[i]插入到容器中去。 要实现这样的数据结构，我们需要学习离散化和树状数组或线段树算法。 树状数组 O(nlogn)以下内容涉及离散化和树状数组的相关知识 将sum[i], sum[i] - upper - 1, sum[i] - lower离散化； 使用一个抽象的数组a，维护数组sum中的元素出现的次数。 使用树状数组，维护数组a的前缀和，使得我们可以在O(logn)的时间复杂度内，将sum[i]出现的次数+1， 查询有多少sum[j]是在范围[sum[i] - upper, sum[i] - lower]内的。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152class Solution &#123;public: typedef long long LL; vector&lt;LL&gt; sum, vals, tr; int n; // 离散化 int get(LL x)&#123; int l = 0, r = vals.size() - 1; while(l &lt; r)&#123; int mid = (l + r) / 2; if(vals[mid] &gt;= x) r = mid; else l = mid + 1; &#125; return l + 1; &#125; // 树状数组的基本操作 int lowerbit(int x)&#123; return x &amp; -x; &#125; // 单点修改 void add(int x, int v)&#123; for(int i = x; i &lt; tr.size(); i += lowerbit(i)) tr[i] += v; &#125; // 区间查询 int query(int x)&#123; int res = 0; for(int i = x; i; i -= lowerbit(i)) res += tr[i]; return res; &#125; int countRangeSum(vector&lt;int&gt;&amp; nums, int lower, int upper) &#123; n = nums.size(); sum = vector&lt;LL&gt;(n + 1); // 将&#x27;sum[i], sum[i] - upper - 1, sum[i] - lower&#x27;离散化； for(int i = 0; i &lt;= n; i ++)&#123; if(i) sum[i] = sum[i - 1] + nums[i - 1]; vals.push_back(sum[i]); vals.push_back(sum[i] - upper - 1); vals.push_back(sum[i] - lower); &#125; sort(vals.begin(), vals.end()); vals.erase(unique(vals.begin(), vals.end()), vals.end()); // 树状数组 tr.resize(vals.size() + 1); int res = 0; for(int i = 0; i &lt;= n; i ++ )&#123; res += query(get(sum[i] - lower)) - query(get(sum[i] - upper - 1)); add(get(sum[i]), 1); &#125; return res; &#125;&#125;; 线段树 O(nlogn)我们使用的是不带懒标记的线段树，实现的功能也是单点修改，区间查询。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081class Solution &#123;public: typedef long long LL; typedef struct&#123; int l, r, sum; &#125;Node; vector&lt;Node&gt; tr; vector&lt;LL&gt; sum, vals; int n; // 离散化 int get(LL x)&#123; int l = 0, r = vals.size() - 1; while(l &lt; r)&#123; int mid = l + r &gt;&gt; 1; if(vals[mid] &gt;= x) r = mid; else l = mid + 1; &#125; return l + 1; &#125; // 线段树基本操作 void pushup(int u)&#123; tr[u].l = tr[u &lt;&lt; 1].l, tr[u].r = tr[u &lt;&lt; 1 | 1].r; tr[u].sum = tr[u &lt;&lt; 1].sum + tr[u &lt;&lt; 1 | 1].sum; &#125; // 建树 void build(int u, int l, int r)&#123; if(l == r)&#123; tr[u].l = tr[u].r = l; return; &#125; int mid = (l + r) &gt;&gt; 1; build(u &lt;&lt; 1, l, mid); build(u &lt;&lt; 1 | 1, mid + 1, r); pushup(u); &#125; // 区间查询 int query(int u, int l, int r)&#123; if(l &lt;= tr[u].l &amp;&amp; tr[u].r &lt;= r) return tr[u].sum; int mid = tr[u].l + tr[u].r &gt;&gt; 1; int res = 0; if(mid &gt;= l) res += query(u &lt;&lt; 1, l, r); if(mid &lt; r) res += query(u &lt;&lt; 1 | 1, l, r); return res; &#125; // 单点修改 void modify(int u, int x, int v)&#123; if(tr[u].l == x &amp;&amp; tr[u].r == x)&#123; tr[u] = &#123;x, x, tr[u].sum + v&#125;; return; &#125; int mid = tr[u].l + tr[u].r &gt;&gt; 1; if(x &lt;= mid) modify(u &lt;&lt; 1, x, v); else modify(u &lt;&lt; 1 | 1, x, v); pushup(u); &#125; int countRangeSum(vector&lt;int&gt;&amp; nums, int lower, int upper) &#123; n = nums.size(); sum.resize(n + 1); // 求前缀和，并且离散化 for(int i = 0; i &lt;= n; i ++ )&#123; if(i) sum[i] = sum[i - 1] + nums[i - 1]; vals.push_back(sum[i]); vals.push_back(sum[i] - upper); vals.push_back(sum[i] - lower); &#125; sort(vals.begin(), vals.end()); vals.erase(unique(vals.begin(), vals.end()), vals.end()); tr.resize(vals.size() * 4 + 10); // 建树 build(1, 1, vals.size()); int res = 0; // 遍历，求结果并插入到线段树中。 for(int i = 0; i &lt;= n; i ++ )&#123; res += query(1, get(sum[i] - upper), get(sum[i] - lower)); modify(1, get(sum[i]), 1); &#125; return res; &#125;&#125;;","categories":[],"tags":[]},{"title":"Leetcode1356. 根据数字二进制下 1 的数目排序","slug":"lc-1356","date":"2020-11-05T16:00:00.000Z","updated":"2020-11-13T06:56:41.973Z","comments":true,"path":"lc-1356/","link":"","permalink":"http://example.com/lc-1356/","excerpt":"题目1356. 根据数字二进制下 1 的数目排序","text":"题目1356. 根据数字二进制下 1 的数目排序 思路统计每个数对应的二进制数的1的个数，然后根据1的个数排序即可。 怎么统计二进制数中1的个数呢？我们可以遍历这个数的每一位，如果这位是1，就计数。这样就可以得到结果了。 代码12345int f(int x)&#123; int cnt = 0; for(int i = 0; i &lt; 32; i ++ ) cnt += (x &gt;&gt; i) &amp; 1; return cnt;&#125; 这样每个数都要遍历32位，在python中一个数可能也不止32位，我们如何得到这个数的1的个数呢？ 可以使用lowerbit算法，lowerbit是一个常用的算法，可以用来得到一个数的最低一位1所在的位置，比如说 $ 6d = 110b $ ，6的最低一位1出现在第二位，lowerbit算法就会返回 $ 10b = 2d $ (b和d分别表示二进制和十进制)。同理 $ lowerbit(8) = 8, lowerbit(12) = 4, …. $ lowerbit算法的代码很简单，只有一行具体的证明请同学们自己思考或者搜索。 代码123int lowerbit(int x)&#123; return x &amp; -x;&#125; 通过lowerbit算法我们如何得到一个数的二进制数中1的个数呢？其实很简单，只要每次找到最低一位1，然后计数，将这个最低一位1从数中减去，直到数为0即可. 代码12345int f(int x)&#123; int cnt = 0; while(x) x -= lowerbit(x), cnt ++ ; return cnt;&#125; 现在我们得到了求一个数的二进制数中1的个数的算法，我们要求数组arr中的所有数的二进制数1的个数，只需要遍历即可。 那么我们可不可以继续优化这个算法的时间复杂度呢？我们可以通过动态规划来进行优化, 给定一个数x，如果我们已知 $ x - lowerbit(x) $ 中有多少个1，那么x就比 $ x - lowerbit(x) $ 多一个1.状态转移方程： f(x) = f(x - lowerbit(x)) + 1 代码12345vector&lt;int&gt; cnt; // cnt[i]记录数字i对应二进制数中1的个数int f(int x)&#123; if(x == 0 || cnt[x] != 0) return cnt[x]; //这个数之前计算过 return cnt[x] = f(x - lowerbit(x)) + 1; // 状态转移方程&#125; 好的，以上就是对于计算一个二进制数中1的个数的算法的优化过程。算法还是挺有趣的，大家加油哦~ 代码123456789101112131415161718192021class Solution &#123;public: vector&lt;int&gt; cnt; // cnt[i]记录数字i对应二进制数中1的个数 // 计算数x对应的二进制数中1的个数 int f(int x)&#123; if(!x || cnt[x] != 0) return cnt[x]; return cnt[x] = f(x - (x &amp; -x)) + 1; &#125; vector&lt;int&gt; sortByBits(vector&lt;int&gt;&amp; arr) &#123; cnt = vector&lt;int&gt;(10010); for(auto t : arr) f(t); sort(arr.begin(), arr.end(), [](int a, int b)-&gt;bool&#123; // 如果两个数a和b对应的二进制数中1的个数不同,1的个数少的在前面 if(cnt[a] != cnt[b]) return cnt[a] &lt; cnt[b]; // 如果相同，小的在前面 return a &lt; b; &#125;); return arr; &#125;&#125;; 附 lambda表达式lambda表达式：很多语言都有的语法糖，可以用来创建匿名函数，简化函数的书写。在sort函数中经常使用，因为我对C++的了解也仅限于做题。所以大家自行搜索吧，hhhh。附上一篇我觉得还可以的博客。 lambda表达式","categories":[],"tags":[]},{"title":"LeetCode127.单词接龙","slug":"lc-127","date":"2020-11-04T16:00:00.000Z","updated":"2020-11-13T06:52:50.352Z","comments":true,"path":"lc-127/","link":"","permalink":"http://example.com/lc-127/","excerpt":"题目127. 单词接龙","text":"题目127. 单词接龙 思路使用广度优先搜索，给定一个单词，搜索其所有可能得到的单词，如果变化后单词在给定的单词集合中，就将其加入到队列中，直到找到最终的单词或者队列为空。 代码1234567891011121314151617181920212223242526272829303132333435class Solution &#123;public: int ladderLength(string beginWord, string endWord, vector&lt;string&gt;&amp; wordList) &#123; // 记录给定的单词集合 unordered_set&lt;string&gt; st; for(auto s : wordList) st.insert(s); // 记录每个单词距离beginword的距离 // 就是beginword改变多少单词可以得到这个单词 unordered_map&lt;string, int&gt; dict; // 起始距离设为1 dict.insert(&#123;beginWord, 1&#125;); // bfs队列 queue&lt;string&gt; q; q.push(beginWord); while(q.size())&#123; auto t = q.front(); q.pop(); // 如果找到答案了，返回结果 if(t == endWord) return dict[t]; // 所有改变一次能得到的单词 for(int i = 0; i &lt; t.size(); i ++ )&#123; auto r = t; for(char c = &#x27;a&#x27;; c &lt;= &#x27;z&#x27;; c ++ )&#123; r[i] = c; // 如果这个单词在集合中，且之前没有被访问过 if(st.count(r) &amp;&amp; !dict.count(r))&#123; q.push(r); dict[r] = dict[t] + 1; &#125; &#125; &#125; &#125; // 没有答案 return 0; &#125;&#125;;","categories":[],"tags":[]},{"title":"Leetcode57. 插入区间","slug":"lc-57","date":"2020-11-03T16:00:00.000Z","updated":"2020-11-13T06:56:58.460Z","comments":true,"path":"lc-57/","link":"","permalink":"http://example.com/lc-57/","excerpt":"题目57. 插入区间","text":"题目57. 插入区间 思路这道题就是一个区间合并的题，首先给定一组有序的区间，和一个要插入的区间，我们可以把这组区间分成三类 在要插入的区间左边，没有交集的区间 和给定区间可以合并成一个区间的区间 最后是剩下的和合并后的区间没有交集的区间。 设：给定区间的左右断点分别为l和r。 对于三类区间： 首先，因为给定的区间都是有序的，所以我们可以先把这些数组加入到答案中，这些数组的都在给定区间的左边，所以他们的右端点是一定在给定区间的左端点的左边的，也就是$intervals[i][1] &lt; l$。 对于第二类区间，是我们要处理的区间，因为我们要将他们进行合并，先想一想他们具有什么样的特征，因为我们目前已经把$intervals[i][1] &lt; l$的区间都排除掉了，所以剩下的区间一定满足$intervals[i][1] &gt;= l$；然后在这些区间里面，什么样的区间是可以和我们给定的区间进行合并的呢？我们先将区间[l, r]初始化为给定的区间，然后我们将所有可以合并的区间合并进去。如果$intervals[i][0] &lt;= r$那么就表示，这个区间的左端点是在我们给定的区间内的，我们就更新区间[l, r] 对于第三类区间，和第一类相同，直接加入到答案里面。 代码1234567891011121314151617181920class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; insert(vector&lt;vector&lt;int&gt;&gt;&amp; intervals, vector&lt;int&gt;&amp; newInterval) &#123; vector&lt;vector&lt;int&gt;&gt; res; // 初始化要合并的区间 int l = newInterval[0], r = newInterval[1]; int i = 0; // 下面将区间分成三类，挨个遍历 // 没有交集的区间 while(i &lt; intervals.size() &amp;&amp; intervals[i][1] &lt; l) res.push_back(intervals[i ++ ]); // 可以合并的区间 while(i &lt; intervals.size() &amp;&amp; intervals[i][0] &lt;= r) l = min(l, intervals[i][0]), r = max(r, intervals[i][1]), i ++ ; res.push_back(&#123;l, r&#125;); // 没有交集的区间 while(i &lt; intervals.size()) res.push_back(intervals[i ++ ]); return res; &#125;&#125;;","categories":[],"tags":[],"author":"Lituo"},{"title":"Leetcode941. 有效的山脉数组","slug":"lc-941","date":"2020-11-02T16:00:00.000Z","updated":"2020-11-13T06:57:19.758Z","comments":true,"path":"lc-941/","link":"","permalink":"http://example.com/lc-941/","excerpt":"题目941. 有效的山脉数组","text":"题目941. 有效的山脉数组 思路模拟题，扫描一遍数组，如果是单调升+单调降的话，就返回true，否则返回false 代码12345678910class Solution &#123;public: bool validMountainArray(vector&lt;int&gt;&amp; A) &#123; int i = 0; while(i + 1 &lt; A.size() &amp;&amp; A[i] &lt; A[i + 1]) i ++ ; if(i == 0 || i == A.size() - 1) return false; while(i + 1 &lt; A.size() &amp;&amp; A[i] &gt; A[i + 1]) i ++ ; return i == A.size() - 1; &#125;&#125;;","categories":[],"tags":[],"author":"Lituo"},{"title":"Leetcode349. 两个数组的交集","slug":"lc-349","date":"2020-11-01T16:00:00.000Z","updated":"2020-11-13T06:54:03.974Z","comments":true,"path":"lc-349/","link":"","permalink":"http://example.com/lc-349/","excerpt":"题目349. 两个数组的交集","text":"题目349. 两个数组的交集 思路使用一个hash表，存储一个数组的所有元素，然后再遍历另一个数组，如果hash表中存在这个元素，就把它加入到答案中。 因为答案是没有重复的，所以在遍历另一个数组的时候，在向答案数组中添加元素的时候，我们就把这个元素从hash表中删除，这样就不会有重复的元素了。 代码123456789101112131415161718192021class Solution &#123;public: vector&lt;int&gt; intersection(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) &#123;​ vector&lt;int&gt; res;​ unordered_set&lt;int&gt; st;​ for(auto t : nums1) st.insert(t);​ for(auto t : nums2)​ if(st.count(t)) st.erase(t), res.push_back(t);​ return res; &#125;&#125;;","categories":[],"tags":[]}],"categories":[],"tags":[]}