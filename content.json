{"meta":{"title":"醒来","subtitle":"","description":"","author":"LiTuo","url":"http://example.com","root":"/"},"pages":[],"posts":[{"title":"lc-127","slug":"2020-11-5-Leetode127.单词接龙","date":"2020-11-04T16:00:00.000Z","updated":"2020-11-05T09:39:21.748Z","comments":true,"path":"2020-11-05/2020-11-5-Leetode127.单词接龙/","link":"","permalink":"http://example.com/2020-11-05/2020-11-5-Leetode127.%E5%8D%95%E8%AF%8D%E6%8E%A5%E9%BE%99/","excerpt":"","text":"题目127. 单词接龙思路使用广度优先搜索，给定一个单词，搜索其所有可能得到的单词，如果变化后单词在给定的单词集合中，就将其加入到队列中，直到找到最终的单词或者队列为空。 代码1234567891011121314151617181920212223242526272829303132333435class Solution &#123;public: int ladderLength(string beginWord, string endWord, vector&lt;string&gt;&amp; wordList) &#123; // 记录给定的单词集合 unordered_set&lt;string&gt; st; for(auto s : wordList) st.insert(s); // 记录每个单词距离beginword的距离 // 就是beginword改变多少单词可以得到这个单词 unordered_map&lt;string, int&gt; dict; // 起始距离设为1 dict.insert(&#123;beginWord, 1&#125;); // bfs队列 queue&lt;string&gt; q; q.push(beginWord); while(q.size())&#123; auto t = q.front(); q.pop(); // 如果找到答案了，返回结果 if(t == endWord) return dict[t]; // 所有改变一次能得到的单词 for(int i = 0; i &lt; t.size(); i ++ )&#123; auto r = t; for(char c = &#x27;a&#x27;; c &lt;= &#x27;z&#x27;; c ++ )&#123; r[i] = c; // 如果这个单词在集合中，且之前没有被访问过 if(st.count(r) &amp;&amp; !dict.count(r))&#123; q.push(r); dict[r] = dict[t] + 1; &#125; &#125; &#125; &#125; // 没有答案 return 0; &#125;&#125;;","categories":[],"tags":[]},{"title":"57. 插入区间","slug":"lc-57","date":"2020-11-03T16:00:00.000Z","updated":"2020-11-04T04:58:19.907Z","comments":true,"path":"2020-11-04/lc-57/","link":"","permalink":"http://example.com/2020-11-04/lc-57/","excerpt":"","text":"题目57. 插入区间思路这道题就是一个区间合并的题，首先给定一组有序的区间，和一个要插入的区间，我们可以把这组区间分成三类 在要插入的区间左边，没有交集的区间 和给定区间可以合并成一个区间的区间 最后是剩下的和合并后的区间没有交集的区间。 设：给定区间的左右断点分别为l和r。 对于三类区间： 首先，因为给定的区间都是有序的，所以我们可以先把这些数组加入到答案中，这些数组的都在给定区间的左边，所以他们的右端点是一定在给定区间的左端点的左边的，也就是$intervals[i][1] &lt; l$。 对于第二类区间，是我们要处理的区间，因为我们要将他们进行合并，先想一想他们具有什么样的特征，因为我们目前已经把$intervals[i][1] &lt; l$的区间都排除掉了，所以剩下的区间一定满足$intervals[i][1] &gt;= l$；然后在这些区间里面，什么样的区间是可以和我们给定的区间进行合并的呢？我们先将区间[l, r]初始化为给定的区间，然后我们将所有可以合并的区间合并进去。如果$intervals[i][0] &lt;= r$那么就表示，这个区间的左端点是在我们给定的区间内的，我们就更新区间[l, r] 对于第三类区间，和第一类相同，直接加入到答案里面。 代码1234567891011121314151617181920class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; insert(vector&lt;vector&lt;int&gt;&gt;&amp; intervals, vector&lt;int&gt;&amp; newInterval) &#123; vector&lt;vector&lt;int&gt;&gt; res; // 初始化要合并的区间 int l = newInterval[0], r = newInterval[1]; int i = 0; // 下面将区间分成三类，挨个遍历 // 没有交集的区间 while(i &lt; intervals.size() &amp;&amp; intervals[i][1] &lt; l) res.push_back(intervals[i ++ ]); // 可以合并的区间 while(i &lt; intervals.size() &amp;&amp; intervals[i][0] &lt;= r) l = min(l, intervals[i][0]), r = max(r, intervals[i][1]), i ++ ; res.push_back(&#123;l, r&#125;); // 没有交集的区间 while(i &lt; intervals.size()) res.push_back(intervals[i ++ ]); return res; &#125;&#125;;","categories":[],"tags":[],"author":"Lituo"},{"title":"941. 有效的山脉数组","slug":"lc-941","date":"2020-11-02T16:00:00.000Z","updated":"2020-11-02T23:51:05.676Z","comments":true,"path":"2020-11-03/lc-941/","link":"","permalink":"http://example.com/2020-11-03/lc-941/","excerpt":"","text":"题目941. 有效的山脉数组思路模拟题，扫描一遍数组，如果是单调升+单调降的话，就返回true，否则返回false 代码12345678910class Solution &#123;public: bool validMountainArray(vector&lt;int&gt;&amp; A) &#123; int i = 0; while(i + 1 &lt; A.size() &amp;&amp; A[i] &lt; A[i + 1]) i ++ ; if(i == 0 || i == A.size() - 1) return false; while(i + 1 &lt; A.size() &amp;&amp; A[i] &gt; A[i + 1]) i ++ ; return i == A.size() - 1; &#125;&#125;;","categories":[],"tags":[],"author":"Lituo"},{"title":"349. 两个数组的交集","slug":"lc-349","date":"2020-11-02T00:32:11.000Z","updated":"2020-11-02T00:33:28.785Z","comments":true,"path":"2020-11-02/lc-349/","link":"","permalink":"http://example.com/2020-11-02/lc-349/","excerpt":"","text":"题目349. 两个数组的交集思路使用一个hash表，存储一个数组的所有元素，然后再遍历另一个数组，如果hash表中存在这个元素，就把它加入到答案中。 因为答案是没有重复的，所以在遍历另一个数组的时候，在向答案数组中添加元素的时候，我们就把这个元素从hash表中删除，这样就不会有重复的元素了。 代码123456789101112131415161718192021class Solution &#123;public: vector&lt;int&gt; intersection(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) &#123;​ vector&lt;int&gt; res;​ unordered_set&lt;int&gt; st;​ for(auto t : nums1) st.insert(t);​ for(auto t : nums2)​ if(st.count(t)) st.erase(t), res.push_back(t);​ return res; &#125;&#125;;","categories":[],"tags":[]}],"categories":[],"tags":[]}